#define FBMNOISE_MODULE
// ----------------------------------------------------------------------------
// Модуль расчета фрактального шума методом, описанным Inigo Quilez
// ----------------------------------------------------------------------------

// ----------------------------------------------------------------------------
// Модуль функций автоматического дифференцирования
// ----------------------------------------------------------------------------
#ifndef AUTODIFF_MODULE
#include "src/shaders/common/Autodiff/Autodiff.glsl";
#endif

// ----------------------------------------------------------------------------
// Модуль функций шума
// ----------------------------------------------------------------------------
#ifndef NOISE_MODULE
#include "src/shaders/common/Noise/NoiseD.glsl";
#endif


const float distmax = 5000.;
const float distmin = 50.;
//const mat2 im2 = mat2(1,0,0,1);
const mat2 im2 = mat2(0.8,-0.6,0.6,0.8);

// Генерация высоты с эррозией и c вычислением нормали
// возвращает
// w - значение
// xyz - частные производные
vec4 terrainFbm(vec2 p, float dist) {
  float a = 0.0;
  float b = 1.0;
  vec2 d = vec2(0);
  vec4 g = ZERO_D, h = ZERO_D;
  mat2 m = mat2(1,0,0,1);
  // число октав от расстояния (вблизи 16, в далеке 9)
  float noct = 16. - (16.-9.)*pow(clamp((dist-distmin)/(distmax-distmin), 0., 1.),0.5);
  float nfract = fract(noct);
  vec4 f;
  float mu;
  int i = 0;
  
  for(; i<5; i++ ) {
    // низкие частоты
    f = noised(m*p);
    f = HALF_D - abs_d(2.*f - ONE_D); // приведение к диапазону [-1 ... +1] и вычисление ridged шума
    a += b*f.w;               // накопление значения высоты
    d += f.xy * m;            // накопление величин производных (b*fr = 1.0 поэтому производные не масштабируются)
    b *= 0.5;                 // уменьшение амплитуды следующей октавы
    p *= 2.0;                 // увеличение частоты следующей октавы
    m = im2 * m;              // вращение плоскости
  }
  //a += 1.5;
  /*
  for(; i<9; i++ ) {
    // низкие частоты
    f = noised(m*p);
    mu = 1./(1.+a*a);
    f = mu * (HALF_D - abs_d(2.*f - ONE_D)); // приведение к диапазону [-1 ... +1] и вычисление ridged шума
    a += b*f.w;               // накопление значения высоты
    d += f.xy * m;            // накопление величин производных (b*fr = 1.0 поэтому производные не масштабируются)
    b *= 0.5;                 // уменьшение амплитуды следующей октавы
    p *= 2.0;                 // увеличение частоты следующей октавы
    m = im2 * m;              // вращение плоскости
  }
  */
  for(; i<int(noct); i++ ) {
    // высокие частоты
    f = noised(m*p);
    mu = 1./(1.+a*a);
    f = mu*f;//square_d(f);          // сглаживание шума на высоких частотах
    a += b*f.w;               // накопление значения высоты
    d += f.xy * m;            // накопление величин производных
    b *= 0.5;                 // уменьшение амплитуды следующей октавы
    p *= 2.0;                 // увеличение частоты следующей октавы
    m = im2 * m;              // вращение плоскости
  }
  f = noised(m*p);
  mu = 1./(1.+a*a);
  f = nfract*mu*f;//square_d(f);
  a += b*f.w;
  d += f.xy * m;
  return vec4(-d, 1, a + 0.7);
}
