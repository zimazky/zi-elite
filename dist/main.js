(()=>{"use strict";var t,r={752:function(t,r,e){var n=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(r,"__esModule",{value:!0});const i=e(331),s=e(764),o=e(115),a=e(490),l=e(421),h=e(100),u=e(704),c=e(385),d=e(270),m=e(193),f=e(237),g=e(386),p=e(9),v=e(460),x=n(e(937)),T=n(e(844)),E=n(e(23)),A=n(e(256)),R=n(e(978)),y=n(e(125));r.default=async function(){const t=document.getElementById("info"),r=new o.Engine("glcanvas");let e=0,n=0;(0,l.initKeyBuffer)();const S=await(0,v.loadImage)("textures/gray_noise.png"),M=await(0,v.loadImage)("textures/blue_noise.png"),_=await(0,v.loadImage)("textures/starmap_2020_16k_gal.jpg"),b=await(0,v.loadImage)("textures/constellation_figures_8k_gal.jpg"),D=new d.TerrainSampler(new h.NoiseSampler(S)),w=localStorage.getItem("ziEliteData")??"{}";console.log("localStorage",w),JSON.parse(w);let P=new m.Vec3(2316,0,7696),I=new u.Quaternion(0,-.9908125427905498,0,.13524239368232574);const N=new s.Camera(P,I,D),L=new i.Atmosphere,C=new c.Sky(N,L),O=new a.Flare(N),z=new a.Flare(N);r.resizeCanvasToDisplaySize();const V=r.addFramebufferMRT(r.canvas.width,r.canvas.height,1,x.default,T.default,(t=>{F.init(t)}),((t,r)=>{F.update()})),U=r.addFramebufferMRT(r.canvas.width,r.canvas.height,2,E.default,A.default,(t=>{B.init(t,S)}),((t,r)=>{B.update(t,r)})),F=new f.ProgramA(r,U,N),B=new g.ProgramB(r,V,N,L),H=new p.ProgramRender(r,V,U,N,L,C,O,z);r.setRenderbuffer(R.default,y.default,(t=>{H.init(t,M,_,b,S)}),((t,r)=>{H.update(t,r)})),r.onUpdate=(i,s)=>{if(N.loopCalculation(i,s),C.loopCalculation(i,s),O.update(i,s),z.update(i,s),i>e){const n=1e3*s,o=N.velocity.length(),a=3.6*o,l=r.canvas.width.toFixed(0),h=r.canvas.height.toFixed(0),u=U.width.toFixed(0),c=U.height.toFixed(0),d=F.numX.toFixed(0),m=F.numY.toFixed(0);t.innerText=`dt: ${n.toFixed(2)} fps: ${(1e3/n).toFixed(2)} ${l}x${h}\n      shB: ${u}x${c} nA: ${d}x${m}\n      v: ${o.toFixed(2)}m/s (${a.toFixed(2)}km/h)\n      alt: ${N.altitude.toFixed(2)} h: ${N.position.y.toFixed(2)}\n      x: ${N.position.x.toFixed(2)} y: ${N.position.z.toFixed(2)}\n      sun: ${C.sunDiscColor.x.toFixed(2)} ${C.sunDiscColor.y.toFixed(2)} ${C.sunDiscColor.z.toFixed(2)}`,e=i+.5}if(i>n){const t=JSON.stringify({position:N.position,orientation:N.orientation});localStorage.setItem("ziEliteData",t),n=i+5}},r.start()}},331:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Atmosphere=void 0;const n=e(24),i=e(921),s=e(193),o=Math.PI*Math.PI*Math.PI,a=1.04345246,l=1/(4*Math.PI);r.Atmosphere=class{constructor(){this.planetRadius=6371e3,this.planetCenter=new s.Vec3(0,-this.planetRadius,0),this.radius=6471e3,this.n=1.00029,this.rgbLambda=new s.Vec3(615e-9,535e-9,445e-9),this.betaRayleigh=new s.Vec3(55e-7,13e-6,224e-7),this.betaMie=s.Vec3.ONE().mulMutable(2e-7),this.g=.996,this.p=.035,this.heightRayleigh=8e3,this.heightMie=1200,this.planetRadius2=this.planetRadius*this.planetRadius,this.radius2=this.radius*this.radius}computeBetaRayleigh(t){const r=this.n*this.n-1,e=t*t;return 8*o*r*r*(6+3*this.p)/(7512000000000001e10*e*e*(6-7*this.p))}ChHOld(t,r,e){const n=t+r,i=a*Math.sqrt(n),s=i*Math.exp(-r);if(e>=0)return s/(i*e+1);{const r=Math.sqrt(1-e*e)*n;return a*Math.sqrt(r)*2*Math.exp(t-r)-s/(1-i*e)}}ChH(t,r,e){const n=t+r,i=a*Math.sqrt(n),s=i*Math.exp(-r);if(e>=0)return s/((i-1)*e+1);{const r=Math.sqrt(1-e*e);return s/((i-1)*e-1)+2*i*Math.exp(t-n*r)*Math.sqrt(r)}}softPlanetShadow(t,r){const e=t.sub(this.planetCenter),s=e.dot(r),o=Math.sqrt(e.dot(e)-s*s);if(s>0)return 1;const a=(this.planetRadius-o)/s;return(0,i.smoothstep)(-n.SUN_DISC_ANGLE_SIN,n.SUN_DISC_ANGLE_SIN,a)}scattering(t,r,e){const n=t.sub(this.planetCenter);let i=n.dot(n),o=-n.dot(r);const a=i-o*o;if(a>=this.radius2)return{t:s.Vec3.ZERO(),i:s.Vec3.ONE()};const h=Math.sqrt(this.radius2-a);let u=2*h;if(i>this.radius2){if(o<0)return{t:s.Vec3.ZERO(),i:s.Vec3.ONE()};n.addMutable(r.mul(o-h)),i=this.radius2,o=h}else u=h-n.dot(r);let c=!1;n.normalize().dot(r)<0&&a<this.planetRadius2&&(u=o-Math.sqrt(this.planetRadius2-a),c=!0);const d=r.dot(e),m=d*d,f=this.g*this.g,g=.75*(1+m)*l,p=1.5*(1-f)/(2+f)*(1+m)/Math.pow(1+f-2*d*this.g,1.5)*l,v=u/32,x=r.mul(v),T=n.add(x),E=n.add(x.mul(.5));let A=0,R=0;const y=s.Vec3.ZERO(),S=s.Vec3.ZERO();let M=v*Math.exp(-(n.length()-this.planetRadius)/this.heightRayleigh),_=v*Math.exp(-(n.length()-this.planetRadius)/this.heightMie);for(let t=0;t<32;t++,T.addMutable(x),E.addMutable(x)){const t=T.length()-this.planetRadius,r=v*Math.exp(-t/this.heightRayleigh),n=v*Math.exp(-t/this.heightMie);A+=.5*(r+M),R+=.5*(n+_),M=r,_=n;const i=E.dot(e),s=E.dot(E)-i*i;if(i>0||s>this.planetRadius2){const t=E.normalize().dot(e),i=E.length()-this.planetRadius,s=this.heightRayleigh*this.ChH(this.planetRadius/this.heightRayleigh,i/this.heightRayleigh,t),o=this.heightMie*this.ChH(this.planetRadius/this.heightMie,i/this.heightMie,t),a=this.betaRayleigh.mul(-A-s).addMutable(this.betaMie.mul(-R-o)).exp();y.addMutable(a.mul(r)),S.addMutable(a.mul(n))}}const b=c?this.betaRayleigh.mul(-A).exp():this.betaRayleigh.mul(-A).addMutable(this.betaMie.mul(-R)).exp();return{t:this.betaRayleigh.mulEl(y).mulMutable(g).addMutable(this.betaMie.mulEl(S).mulMutable(p)),i:b}}transmittance(t,r){const e=t.sub(this.planetCenter);let n=e.dot(e),i=-e.dot(r);const o=n-i*i;if(o>=this.radius2)return s.Vec3.ZERO();const a=Math.sqrt(this.radius2-o);let h=2*a;if(n>this.radius2){if(i<0)return s.Vec3.ZERO();e.addMutable(r.mul(i-a)),n=this.radius2,i=a}else h=a-e.dot(r);let u=!1;e.normalize().dot(r)<0&&o<this.planetRadius2&&(h=i-Math.sqrt(this.planetRadius2-o));const c=this.g*this.g,d=1.5*l,m=1.5*(1-c)/(2+c)*2/Math.pow(1+c-2*this.g,1.5)*l,f=h/32,g=r.mul(f),p=e.add(g),v=e.add(g.mul(.5));let x=0,T=0;const E=s.Vec3.ZERO(),A=s.Vec3.ZERO();let R=f*Math.exp(-(e.length()-this.planetRadius)/this.heightRayleigh),y=f*Math.exp(-(e.length()-this.planetRadius)/this.heightMie);for(let t=0;t<32;t++,p.addMutable(g),v.addMutable(g)){const t=p.length()-this.planetRadius,r=f*Math.exp(-t/this.heightRayleigh),e=f*Math.exp(-t/this.heightMie);x+=.5*(r+R),T+=.5*(e+y),R=r,y=e;const n=this.betaRayleigh.mul(-x).addMutable(this.betaMie.mul(-T)).exp();E.addMutable(n.mul(r)),A.addMutable(n.mul(e))}return this.betaRayleigh.mulEl(E).mulMutable(d).addMutable(this.betaMie.mulEl(A).mulMutable(m))}}},764:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Camera=r.MAP_VIEW=r.FRONT_VIEW=void 0;const n=e(421),i=e(704),s=e(193);r.FRONT_VIEW=0,r.MAP_VIEW=1;const o=new s.Vec3(.01,.05,.001).mulMutable(58),a=Math.PI/180;r.Camera=class{constructor(t,r,e){this.direction=new s.Vec3(0,0,-1),this.transformMat=s.Mat3.ID(),this.transformMatPrev=s.Mat3.ID(),this.positionDelta=s.Vec3.ZERO(),this.headLights=0,this.position=t.copy(),this.velocity=s.Vec3.ZERO(),this.angularSpeed=s.Vec3.ZERO(),this.orientation=r,this.viewAngle=80*Math.PI/180,this.tSampler=e,this.screenMode=0,this.mapMode=0,this.mapScale=5e3}inShadow(t,r,e){const n=t.softPlanetShadow(r,e);if(n<=.001)return 0;const i=n*this.tSampler.softShadow(this.position,e);return Math.pow(i,4)}loopCalculation(t,e){const l=new s.Vec3(0,0,(0,n.isKeyDown)(83)-(0,n.isKeyDown)(87));this.transformMatPrev=this.transformMat;const h=this.orientation.mat3();this.transformMat=h,this.velocity.addMutable(h.mul(l).mulMutable(11*e)),this.velocity.subMutable(h.mul(h.mulLeft(this.velocity).mulElMutable(o)).mulMutable(e)),this.velocity.y-=0*e,(0,n.isKeyDown)(32)>0&&(this.velocity=s.Vec3.ZERO()),this.positionDelta=this.position.copy(),this.position.addMutable(this.velocity.mul(e));const u=this.tSampler.terrainM(new s.Vec2(this.position.x,this.position.z))+2;this.position.y<u&&(this.velocity.y=0,this.position.y=u),this.positionDelta=this.position.sub(this.positionDelta),this.altitude=this.position.y-u;const c=new s.Vec3((0,n.isKeyDown)(40)-(0,n.isKeyDown)(38),(0,n.isKeyDown)(188)-(0,n.isKeyDown)(190),2*((0,n.isKeyDown)(37)-(0,n.isKeyDown)(39)));this.angularSpeed.addMutable(c.mulMutable(3*a*e)),this.angularSpeed.subMutable(this.angularSpeed.mul(3*e));const d=this.angularSpeed.mul(20*e);this.orientation=this.orientation.qmul(new i.Quaternion(0,0,Math.sin(d.z),Math.cos(d.z))),this.orientation=this.orientation.qmul(new i.Quaternion(Math.sin(d.x),0,0,Math.cos(d.x))),this.orientation=this.orientation.qmul(new i.Quaternion(0,Math.sin(d.y),0,Math.cos(d.y))),this.orientation.normalizeMutable(),this.direction=this.orientation.rotate(new s.Vec3(0,0,-1)),(0,n.isKeyPress)(77)>0&&(this.screenMode=this.screenMode==r.FRONT_VIEW?r.MAP_VIEW:r.FRONT_VIEW),this.screenMode==r.MAP_VIEW?(this.mapScale*=1+.01*((0,n.isKeyDown)(109)+(0,n.isKeyDown)(189)-(0,n.isKeyDown)(107)-(0,n.isKeyDown)(187)),(0,n.isKeyPress)(71)>0&&(this.mapMode^=1),(0,n.isKeyPress)(72)>0&&(this.mapMode^=2)):this.viewAngle+=.01*((0,n.isKeyDown)(109)-(0,n.isKeyDown)(107)),(0,n.isKeyPress)(76)>0&&(this.headLights=0==this.headLights?100:0)}}},24:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.SUN_COLOR=r.SUN_DISC_ANGLE_SIN=void 0;const n=e(193);r.SUN_DISC_ANGLE_SIN=.008725,r.SUN_COLOR=n.Vec3.ONE()},115:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Engine=void 0;const n=e(318);class i extends n.GLContext{constructor(t){super(t),this.textures=[],this.framebuffers=[],this.onUpdate=(t,r)=>{}}addFramebufferMRT(t,r,e,n,i,s=(t=>{}),o=((t,r)=>{})){const a=this.createProgram(n,i),[l,h]=this.createFramebufferMRT(t,r,e);this.gl.useProgram(a);const u=this.gl.getUniformLocation(a,"uResolution"),c=this.gl.getUniformLocation(a,"uTime");return this.framebuffers.push({width:t,height:r,program:a,framebuffer:l,fbTextures:h,vertexArray:null,numOfVertices:4,isElementDraw:!1,isDepthTest:!1,clearColor:null,drawMode:this.gl.TRIANGLE_STRIP,resolutionLocation:u,timeLocation:c,onProgramInit:s,onProgramLoop:o}),this.framebuffers[this.framebuffers.length-1]}setRenderbuffer(t,r,e=(t=>{}),n=((t,r)=>{})){const i=this.createProgram(t,r);this.gl.useProgram(i);const s=this.gl.getUniformLocation(i,"uResolution"),o=this.gl.getUniformLocation(i,"uTime");this.renderbufer={program:i,vertexArray:null,numOfVertices:4,isElementDraw:!1,isDepthTest:!1,clearColor:null,drawMode:this.gl.TRIANGLE_STRIP,resolutionLocation:s,timeLocation:o,onProgramInit:e,onProgramLoop:n}}async loadShader(t){let r=await fetch(t);return await r.text()}setVertexArray(t,r,e,n,i=2){t.vertexArray=this.gl.createVertexArray(),t.numOfVertices=e.length/i,this.gl.bindVertexArray(t.vertexArray);const s=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,s),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array(e),this.gl.STATIC_DRAW);const o=this.gl.getAttribLocation(t.program,r);if(this.gl.enableVertexAttribArray(o),this.gl.vertexAttribPointer(o,i,this.gl.FLOAT,!1,0,0),null===n)return;t.isElementDraw=!0,t.numOfVertices=n.length;const a=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER,a),this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER,new Uint32Array(n),this.gl.STATIC_DRAW)}setRenderedTexture(t,r,e){const n=this.gl.getUniformLocation(t,e);let i=this.textures.findIndex((t=>t==r));-1===i&&(i=this.textures.length,this.textures.push(r)),this.gl.uniform1i(n,i),this.gl.activeTexture(this.gl.TEXTURE0+i),this.gl.bindTexture(this.gl.TEXTURE_2D,r)}resizeCanvasToDisplaySize(){if(void 0===this.canvas)return;const t=window.innerWidth,r=window.innerHeight;this.canvas.width===t&&this.canvas.height===r||(this.canvas.width=t,this.canvas.height=r,this.gl.viewport(0,0,this.canvas.width,this.canvas.height))}setTexture(t,r,e){const n=this.gl.createTexture(),i=this.textures.length;this.gl.activeTexture(this.gl.TEXTURE0+i),this.gl.bindTexture(this.gl.TEXTURE_2D,n),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.REPEAT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.REPEAT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e);const s=this.gl.getUniformLocation(t,r);return this.gl.uniform1i(s,i),this.textures.push(n),n}setTextureWithArray16F(t,r,e,n,i){const s=this.gl.createTexture(),o=this.textures.length;this.gl.activeTexture(this.gl.TEXTURE0+o),this.gl.bindTexture(this.gl.TEXTURE_2D,s),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.REPEAT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.REPEAT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGB16F,e,n,0,this.gl.RGB,this.gl.FLOAT,i);const a=this.gl.getUniformLocation(t,r);return this.gl.uniform1i(a,o),this.textures.push(s),s}setTextureWithMIP(t,r,e){const n=this.gl.createTexture(),i=this.textures.length;this.gl.activeTexture(this.gl.TEXTURE0+i),this.gl.bindTexture(this.gl.TEXTURE_2D,n),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.REPEAT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.REPEAT),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR_MIPMAP_LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.gl.generateMipmap(this.gl.TEXTURE_2D);const s=this.gl.getUniformLocation(t,r);return this.gl.uniform1i(s,i),this.textures.push(n),n}start(){this.resizeCanvasToDisplaySize(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.gl.createBuffer()),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([1,1,-1,1,1,-1,-1,-1]),this.gl.STATIC_DRAW),this.gl.enableVertexAttribArray(0),this.gl.vertexAttribPointer(0,2,this.gl.FLOAT,!1,0,0),this.framebuffers.forEach((t=>{this.gl.useProgram(t.program),t.onProgramInit(t)})),this.gl.useProgram(this.renderbufer.program),this.renderbufer.onProgramInit(this.renderbufer),this.startTime=this.currentTime=performance.now()/1e3,this.loop()}loop(){const t=performance.now()/1e3,r=t-this.startTime,e=t-this.currentTime;this.currentTime=t,this.onUpdate(r,e),this.framebuffers.forEach((t=>{this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,t.framebuffer),t.fbTextures.length>1&&this.gl.drawBuffers(t.fbTextures.map(((t,r)=>this.gl.COLOR_ATTACHMENT0+r))),this.gl.useProgram(t.program),null!==t.clearColor?(this.gl.clearColor(t.clearColor.x,t.clearColor.y,t.clearColor.z,t.clearColor.w),t.isDepthTest?this.gl.enable(this.gl.DEPTH_TEST):this.gl.disable(this.gl.DEPTH_TEST),this.gl.clear(this.gl.COLOR_BUFFER_BIT|this.gl.DEPTH_BUFFER_BIT)):t.isDepthTest?(this.gl.enable(this.gl.DEPTH_TEST),this.gl.clear(this.gl.DEPTH_BUFFER_BIT)):this.gl.disable(this.gl.DEPTH_TEST),this.gl.bindVertexArray(t.vertexArray),this.gl.uniform2f(t.resolutionLocation,t.width,t.height),this.gl.uniform2f(t.timeLocation,r,e),this.gl.viewport(0,0,t.width,t.height),t.isElementDraw?this.gl.drawElements(t.drawMode,t.numOfVertices,this.gl.UNSIGNED_INT,0):this.gl.drawArrays(t.drawMode,0,t.numOfVertices),t.onProgramLoop(r,e)})),this.resizeCanvasToDisplaySize(),this.gl.disable(this.gl.DEPTH_TEST),this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null),this.gl.useProgram(this.renderbufer.program),this.gl.bindVertexArray(this.renderbufer.vertexArray),this.gl.uniform2f(this.renderbufer.resolutionLocation,this.canvas.width,this.canvas.height),this.gl.uniform2f(this.renderbufer.timeLocation,r,e),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.renderbufer.isElementDraw?this.gl.drawElements(this.renderbufer.drawMode,this.renderbufer.numOfVertices,this.gl.UNSIGNED_INT,0):this.gl.drawArrays(this.renderbufer.drawMode,0,this.renderbufer.numOfVertices),this.renderbufer.onProgramLoop(r,e),requestAnimationFrame(this.loop.bind(this))}}r.Engine=i},490:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Flare=void 0;const n=e(193),i=e(421),s=e(921);r.Flare=class{constructor(t,r=new n.Vec3(100,100,100)){this.velocity=n.Vec3.ZERO(),this.initialSpeed=100,this.initialDirection=new n.Vec3(0,Math.sin((0,s.rad)(15)),-Math.cos((0,s.rad)(15))),this.isVisible=!1,this.g=9.81,this.n=0,this.camera=t,this.position=this.camera.position.copy(),this.light=r}update(t,r){if(this.isVisible){this.position.addMutable(this.velocity.mul(r)),this.velocity.addMutable(new n.Vec3(0,-this.g*r,0));const t=this.camera.tSampler.terrainM(new n.Vec2(this.position.x,this.position.z)),e=this.position.y-t;if(e<0){if(++this.n>0)return void(this.isVisible=!1);this.position.y-=e;const t=this.camera.tSampler.calcNormalM(this.position,200);this.velocity.addMutable(t.mul(-1.1*t.dot(this.velocity))).mulMutable(.6)}}else(0,i.isKeyPress)(70)>0&&(this.isVisible=!0,this.n=0,this.position=this.camera.position.add(this.camera.orientation.rotate(n.Vec3.I())),this.velocity=this.camera.velocity.add(this.camera.orientation.rotate(this.initialDirection).mul(this.initialSpeed)))}}},318:(t,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.GLContext=void 0,r.GLContext=class{constructor(t){if(void 0!==t){if(this.canvas=document.getElementById(t),void 0===this.canvas)throw new Error("Cannot find element named: "+t)}else this.canvas=document.createElement("canvas"),document.body.appendChild(this.canvas);if(this.gl=this.canvas.getContext("webgl2"),!this.gl)throw new Error("Unable to initialize WebGL. Your browser or machine may not support it.");this.gl.getExtension("EXT_color_buffer_float")}createShader(t,r){const e=this.gl.createShader(t);return this.gl.shaderSource(e,r.trim()),this.gl.compileShader(e),this.gl.getShaderParameter(e,this.gl.COMPILE_STATUS)?e:(alert("Error compiling shader: "+this.gl.getShaderInfoLog(e)),this.gl.deleteShader(e),null)}createProgram(t,r){const e=this.createShader(this.gl.VERTEX_SHADER,t),n=this.createShader(this.gl.FRAGMENT_SHADER,r),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,n),this.gl.linkProgram(i),this.gl.getProgramParameter(i,this.gl.LINK_STATUS)?i:(alert("Unable to initialize the shader program: "+this.gl.getProgramInfoLog(i)),null)}createFramebuffer0(t,r){const e=this.gl.createFramebuffer();this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,e);const n=this.gl.createTexture();this.gl.bindTexture(this.gl.TEXTURE_2D,n),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA16F,t,r,0,this.gl.RGBA,this.gl.FLOAT,null),this.gl.texParameterf(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameterf(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameterf(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0,this.gl.TEXTURE_2D,n,0);const i=this.gl.createRenderbuffer();this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,i),this.gl.renderbufferStorage(this.gl.RENDERBUFFER,this.gl.DEPTH_COMPONENT16,t,r),this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER,this.gl.DEPTH_ATTACHMENT,this.gl.RENDERBUFFER,i);const s=this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);if(s!==this.gl.FRAMEBUFFER_COMPLETE)throw new Error("Framebuffer object is incomplete: "+s.toString());return[e,n]}createFramebufferMRT(t,r,e){const n=this.gl.createFramebuffer();this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,n);const i=[];for(let n=0;n<e;n++){const e=this.gl.createTexture();i.push(e),this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA16F,t,r,0,this.gl.RGBA,this.gl.FLOAT,null),this.gl.texParameterf(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameterf(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameterf(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.framebufferTexture2D(this.gl.FRAMEBUFFER,this.gl.COLOR_ATTACHMENT0+n,this.gl.TEXTURE_2D,e,0)}const s=this.gl.createRenderbuffer();this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,s),this.gl.renderbufferStorage(this.gl.RENDERBUFFER,this.gl.DEPTH_COMPONENT16,t,r),this.gl.framebufferRenderbuffer(this.gl.FRAMEBUFFER,this.gl.DEPTH_ATTACHMENT,this.gl.RENDERBUFFER,s);const o=this.gl.checkFramebufferStatus(this.gl.FRAMEBUFFER);if(o!==this.gl.FRAMEBUFFER_COMPLETE)throw new Error("Framebuffer object is incomplete: "+o.toString());return[n,i]}}},421:(t,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.isKeyDown=r.isKeyPress=r.initKeyBuffer=void 0;const e=Array(256).fill(0);function n(t){t.keyCode>=256||(e[t.keyCode]=1,t.preventDefault())}function i(t){t.keyCode>=256||(e[t.keyCode]=0,t.preventDefault())}r.initKeyBuffer=function(){window.addEventListener("keydown",n,!1),window.addEventListener("keyup",i,!1)},r.isKeyPress=function(t){const r=e[t];return e[t]=0,r},r.isKeyDown=function(t){return e[t]}},921:(t,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.rad=r.mix=r.smoothstep=void 0,r.smoothstep=function(t,r,e){if(e<=t)return 0;if(e>=r)return 1;const n=(e-t)/(r-t);return n*n*(3-2*n)},r.mix=function(t,r,e){return t+e*(r-t)},r.rad=function(t){return Math.PI*t/180}},100:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.NoiseSampler=void 0;const n=e(193);r.NoiseSampler=class{constructor(t){const r=document.createElement("canvas");r.width=t.width,r.height=t.height;const e=r.getContext("2d");e.drawImage(t,0,0,t.width,t.height),this._data=e.getImageData(0,0,r.width,r.height)}getSample(t){const r=t.fract(),e=Math.floor(r.x*this._data.width),n=Math.floor(r.y*this._data.height);return this._data.data[n*this._data.width+e<<2]/255}noiseD(t){const r=t.floor(),e=t.copy().subMutable(r),i=new n.Vec2(3,3).subMutable(e.mul(2)).mulElMutable(e).mulElMutable(e),s=new n.Vec2(1,1).subMutable(e).mulElMutable(e).mulMutable(6),o=this.getSample(new n.Vec2(.5,.5).addMutable(r).divMutable(256)),a=this.getSample(new n.Vec2(1.5,.5).addMutable(r).divMutable(256)),l=this.getSample(new n.Vec2(.5,1.5).addMutable(r).divMutable(256)),h=this.getSample(new n.Vec2(1.5,1.5).addMutable(r).divMutable(256));return{value:o+(a-o)*i.x+(l-o)*i.y+(o-a-l+h)*i.x*i.y,derivative:new n.Vec2(s.x*(i.y*(o-a-l+h)+a-o),s.y*(i.x*(o-a-l+h)+l-o))}}}},704:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Quaternion=void 0;const n=e(193);class i extends n.Vec4{invert(){return new i(-this.x,-this.y,-this.z,this.w).divMutable(this.dot(this))}qmul(t){return new i(this.w*t.x+this.x*t.w+this.y*t.z-this.z*t.y,this.w*t.y+this.y*t.w+this.z*t.x-this.x*t.z,this.w*t.z+this.z*t.w+this.x*t.y-this.y*t.x,this.w*t.w-this.x*t.x-this.y*t.y-this.z*t.z)}rotate(t){const r=new i(t.x,t.y,t.z,0),e=this.qmul(r).qmul(this.invert());return new n.Vec3(e.x,e.y,e.z)}mat3(){return new n.Mat3(this.rotate(n.Vec3.I()),this.rotate(n.Vec3.J()),this.rotate(n.Vec3.K()))}static byAngle(t,r){const e=.5*r,n=t.mul(Math.sin(e));return new i(n.x,n.y,n.z,Math.cos(e))}static byYawPitchRoll(t,r,e){return i.byAngle(n.Vec3.I(),r).qmul(i.byAngle(n.Vec3.J(),t).qmul(i.byAngle(n.Vec3.K(),e)))}}r.Quaternion=i,i.Identity=()=>new i(0,0,0,1)},385:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Sky=void 0;const n=e(704),i=e(193),s=e(421),o=e(24),a=.12*Math.PI;r.Sky=class{constructor(t,r){this.quat=n.Quaternion.byAngle(i.Vec3.I(),.5*Math.PI),this.axis=new i.Vec3(0,Math.cos(a),-Math.sin(a)),this.period=1200,this.sunDir=new i.Vec3(0,-Math.sin(a),-Math.cos(a)),this.moonDir=new i.Vec3(0,Math.sin(a),Math.cos(a)),this.orientation=n.Quaternion.Identity(),this.transformMat=i.Mat3.ID(),this.isShowConstellations=!1,this.sunDirection=this.sunDir.copy(),this.moonDirection=this.moonDir.copy(),this.skyRefreshTime=0,this.sunDiscColor=i.Vec3.ZERO(),this.moonDiskColor=new i.Vec3(.005,.005,.01),this.skyColor=i.Vec3.ZERO(),this.camera=t,this.atm=r}loopCalculation(t,r){if(this.orientation=n.Quaternion.byAngle(this.axis,-2*Math.PI*(.205+t/this.period)),this.transformMat=this.orientation.qmul(this.quat).mat3(),this.sunDirection=this.orientation.rotate(this.sunDir).normalize(),this.moonDirection=this.orientation.rotate(this.moonDir).normalize(),(0,s.isKeyPress)(67)>0&&(this.isShowConstellations=!this.isShowConstellations),t>this.skyRefreshTime){const r=new i.Vec3(this.camera.position.x,0,this.camera.position.z),e=this.sunDirection.copy();e.y<0&&(e.y=0),e.normalizeMutable();const n=this.atm.scattering(r,e,e),s=o.SUN_COLOR.mul(20);this.sunDiscColor=s.mulEl(n.t).safeNormalize().mulMutable(2);const a=1/Math.sqrt(2),l=this.atm.scattering(r,i.Vec3.J(),this.sunDirection).t.add(this.atm.scattering(r,new i.Vec3(a,a,0),this.sunDirection).t).add(this.atm.scattering(r,new i.Vec3(-a,a,0),this.sunDirection).t).add(this.atm.scattering(r,new i.Vec3(0,a,a),this.sunDirection).t).add(this.atm.scattering(r,new i.Vec3(0,a,-a),this.sunDirection).t).div(5);this.skyColor=s.mulEl(l),this.skyRefreshTime=t+.05}}}},270:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.TerrainSampler=void 0;const n=e(24),i=e(921),s=e(193),o=new s.Mat2(new s.Vec2(.8,-.6),new s.Vec2(.6,.8)),a=3e3,l=1100;r.TerrainSampler=class{constructor(t){this._noiseSampler=t}terrainH(t){let r=t.div(a),e=0,n=1;const i=s.Vec2.ZERO();for(let t=0;t<16;t++){const t=this._noiseSampler.noiseD(r);i.addMutable(t.derivative),e+=n*t.value/(1+i.dot(i)),n*=.5,r=o.mul(r.add(r))}return l*e}terrainM(t){let r=t.div(a),e=0,n=1;const i=s.Vec2.ZERO();for(let t=0;t<9;t++){const t=this._noiseSampler.noiseD(r);i.addMutable(t.derivative),e+=n*t.value/(1+i.dot(i)),n*=.5,r=o.mul(r.add(r))}return l*e}terrainS(t){let r=t.div(a),e=0,n=1;const i=s.Vec2.ZERO();for(let t=0;t<5;t++){const t=this._noiseSampler.noiseD(r);i.addMutable(t.derivative),e+=n*t.value/(1+i.dot(i)),n*=.5,r=o.mul(r.add(r))}return l*e}calcNormalM(t,r){const e=new s.Vec2(.001*r,0);return new s.Vec3(this.terrainM(new s.Vec2(t.x-e.x,t.z-e.y))-this.terrainM(new s.Vec2(t.x+e.x,t.z+e.y)),2*e.x,this.terrainM(new s.Vec2(t.x-e.y,t.z-e.x))-this.terrainM(new s.Vec2(t.x+e.y,t.z+e.x))).normalize()}softShadow(t,r){let e=1,o=.1;const a=Math.sqrt(1-r.z*r.z);for(let l=0;l<200;l++){const l=t.add(r.mul(o));if(l.y>1980)return(0,i.smoothstep)(-n.SUN_DISC_ANGLE_SIN,n.SUN_DISC_ANGLE_SIN,e);const h=l.y-this.terrainM(new s.Vec2(l.x,l.z));if(e=Math.min(e,a*h/o),e<-n.SUN_DISC_ANGLE_SIN)return(0,i.smoothstep)(-n.SUN_DISC_ANGLE_SIN,n.SUN_DISC_ANGLE_SIN,e);o+=Math.max(1,.6*Math.abs(h))}return 0}}},193:(t,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.Mat2=r.Vec2=r.Mat3=r.Vec3=r.Mat4=r.Vec4=void 0;class e{constructor(t,r,e,n){this.x=t,this.y=r,this.z=e,this.w=n}addMutable(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this.w+=t.w,this}subMutable(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this.w-=t.w,this}mulMutable(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}divMutable(t){return this.x/=t,this.y/=t,this.z/=t,this.w/=t,this}mulElMutable(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this.w*=t.w,this}divElMutable(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this.w/=t.w,this}normalizeMutable(){return this.divMutable(Math.sqrt(this.dot(this)))}add(t){return this.copy().addMutable(t)}sub(t){return this.copy().subMutable(t)}mul(t){return this.copy().mulMutable(t)}div(t){return this.copy().divMutable(t)}mulEl(t){return this.copy().mulElMutable(t)}divEl(t){return this.copy().divElMutable(t)}normalize(){return this.copy().normalizeMutable()}length(){return Math.sqrt(this.dot(this))}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z+this.w*t.w}copy(){return new e(this.x,this.y,this.z,this.w)}floor(){return new e(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fract(){return this.copy().subMutable(this.floor())}getArray(){return[this.x,this.y,this.z,this.w]}}r.Vec4=e,e.ZERO=()=>new e(0,0,0,0),e.ONE=()=>new e(1,1,1,1),e.I=()=>new e(1,0,0,0),e.J=()=>new e(0,1,0,0),e.K=()=>new e(0,0,1,0),e.L=()=>new e(0,0,0,1);class n{constructor(t,r,e,n){this.i=t.copy(),this.j=r.copy(),this.k=e.copy(),this.l=n.copy()}mulLeft(t){return new e(this.i.dot(t),this.j.dot(t),this.k.dot(t),this.l.dot(t))}mul(t){return new e(t.x*this.i.x+t.y*this.j.x+t.z*this.k.x+t.w*this.l.x,t.x*this.i.y+t.y*this.j.y+t.z*this.k.y+t.w*this.l.y,t.x*this.i.z+t.y*this.j.z+t.z*this.k.z+t.w*this.l.z,t.x*this.i.w+t.y*this.j.w+t.z*this.k.w+t.w*this.l.w)}getArray(){return[this.i.x,this.i.y,this.i.z,this.i.w,this.j.x,this.j.y,this.j.z,this.j.w,this.k.x,this.k.y,this.k.z,this.k.w,this.l.x,this.l.y,this.l.z,this.l.w]}static orthoProjectMatrix(t,r,i,s,o,a){return new n(new e(2/(r-t),0,0,-(r+t)/(r-t)),new e(0,2/(s-i),0,-(s+i)/(s-i)),new e(0,0,-2/(a-o),-(a+o)/(a-o)),new e(0,0,0,1))}static perspectiveProjectMatrix(t,r,i,s){return new n(new e(1/Math.tan(.5*t),0,0,0),new e(0,r/Math.tan(.5*t),0,0),new e(0,0,-(s+i)/(s-i),-2*s*i/(s-i)),new e(0,0,-1,0))}}r.Mat4=n,n.ID=()=>new n(e.I(),e.J(),e.K(),e.L()),n.ZERO=()=>new n(e.ZERO(),e.ZERO(),e.ZERO(),e.ZERO());class i{constructor(t,r,e){this.x=t,this.y=r,this.z=e}addMutable(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}subMutable(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}mulMutable(t){return this.x*=t,this.y*=t,this.z*=t,this}divMutable(t){return this.x/=t,this.y/=t,this.z/=t,this}mulElMutable(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}divElMutable(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}normalizeMutable(){return this.divMutable(Math.sqrt(this.dot(this)))}safeNormalize(){const t=Math.sqrt(this.dot(this));return t<Number.MIN_VALUE?i.ZERO():this.div(t)}colorNormalize(){const t=Math.max(this.x,this.y,this.z);return t<Number.MIN_VALUE?i.ZERO():this.div(t)}add(t){return this.copy().addMutable(t)}sub(t){return this.copy().subMutable(t)}mul(t){return this.copy().mulMutable(t)}div(t){return this.copy().divMutable(t)}mulEl(t){return this.copy().mulElMutable(t)}divEl(t){return this.copy().divElMutable(t)}normalize(){return this.copy().normalizeMutable()}length(){return Math.sqrt(this.dot(this))}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}copy(){return new i(this.x,this.y,this.z)}floor(){return new i(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z))}fract(){return this.copy().subMutable(this.floor())}exp(){return new i(Math.exp(this.x),Math.exp(this.y),Math.exp(this.z))}getArray(){return[this.x,this.y,this.z]}cross(t){return new i(this.y*t.z-this.z*t.y,this.z*t.x-this.x*t.z,this.x*t.y-this.y*t.x)}}r.Vec3=i,i.ZERO=()=>new i(0,0,0),i.ONE=()=>new i(1,1,1),i.I=()=>new i(1,0,0),i.J=()=>new i(0,1,0),i.K=()=>new i(0,0,1);class s{constructor(t,r,e){this.i=t.copy(),this.j=r.copy(),this.k=e.copy()}mulLeft(t){return new i(this.i.dot(t),this.j.dot(t),this.k.dot(t))}mul(t){return new i(t.x*this.i.x+t.y*this.j.x+t.z*this.k.x,t.x*this.i.y+t.y*this.j.y+t.z*this.k.y,t.x*this.i.z+t.y*this.j.z+t.z*this.k.z)}getArray(){return[this.i.x,this.i.y,this.i.z,this.j.x,this.j.y,this.j.z,this.k.x,this.k.y,this.k.z]}}r.Mat3=s,s.ID=()=>new s(i.I(),i.J(),i.K()),s.ZERO=()=>new s(i.ZERO(),i.ZERO(),i.ZERO());class o{constructor(t,r){this.x=t,this.y=r}addMutable(t){return this.x+=t.x,this.y+=t.y,this}subMutable(t){return this.x-=t.x,this.y-=t.y,this}mulMutable(t){return this.x*=t,this.y*=t,this}divMutable(t){return this.x/=t,this.y/=t,this}mulElMutable(t){return this.x*=t.x,this.y*=t.y,this}divElMutable(t){return this.x/=t.x,this.y/=t.y,this}normalizeMutable(){return this.divMutable(Math.sqrt(this.dot(this)))}add(t){return this.copy().addMutable(t)}sub(t){return this.copy().subMutable(t)}mul(t){return this.copy().mulMutable(t)}div(t){return this.copy().divMutable(t)}mulEl(t){return this.copy().mulElMutable(t)}divEl(t){return this.copy().divElMutable(t)}normalize(){return this.copy().normalizeMutable()}length(){return Math.sqrt(this.dot(this))}dot(t){return this.x*t.x+this.y*t.y}copy(){return new o(this.x,this.y)}floor(){return new o(Math.floor(this.x),Math.floor(this.y))}fract(){return this.copy().subMutable(this.floor())}getArray(){return[this.x,this.y]}cross(t){return this.x*t.y-this.y*t.x}}r.Vec2=o,o.ZERO=()=>new o(0,0),o.ONE=()=>new o(1,1),o.I=()=>new o(1,0),o.J=()=>new o(0,1);class a{constructor(t,r){this.i=t.copy(),this.j=r.copy()}mulLeft(t){return new o(this.i.dot(t),this.j.dot(t))}mul(t){return new o(t.x*this.i.x+t.y*this.j.x,t.x*this.i.y+t.y*this.j.y)}getArray(){return[this.i.x,this.i.y,this.j.x,this.j.y]}}r.Mat2=a,a.ID=()=>new a(o.I(),o.J()),a.ZERO=()=>new a(o.ZERO(),o.ZERO())},237:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.ProgramA=void 0;const n=e(193);r.ProgramA=class{constructor(t,r,e){this.engine=t,this.bufferInput=r,this.camera=e,this.numX=Math.ceil(t.canvas.width/2.3),this.numY=Math.ceil(t.canvas.height/2.3)}init(t){this.engine.setRenderedTexture(t.program,this.bufferInput.fbTextures[0],"uTextureProgramB");const r=this.engine.gl.getUniformLocation(t.program,"uTextureBResolution");this.engine.gl.uniform2f(r,this.bufferInput.width,this.bufferInput.height);const e=this.engine.gl.getUniformLocation(t.program,"uNetResolution");this.engine.gl.uniform2f(e,this.numX,this.numY),this.uProjectMatrix=this.engine.gl.getUniformLocation(t.program,"uProjectMatrix"),this.uTransformMatrix=this.engine.gl.getUniformLocation(t.program,"uTransformMatrix"),this.uTransformMatrixPrev=this.engine.gl.getUniformLocation(t.program,"uTransformMatrixPrev"),this.uPositionDelta=this.engine.gl.getUniformLocation(t.program,"uPositionDelta"),this.uCameraViewAngle=this.engine.gl.getUniformLocation(t.program,"uCameraViewAngle");const i=[];for(let t=0;t<this.numY+1;t++)for(let r=0;r<this.numX+1;r++)i.push(2*r/this.numX-1),i.push(2*t/this.numY-1);const s=[];for(let t=0;t<this.numX+1;t+=4)for(let r=0;r<this.numY;r++)for(let e=t;e-t<4&&e<this.numX;e++)s.push(e+r*(this.numX+1)),s.push(e+1+r*(this.numX+1)),s.push(e+(r+1)*(this.numX+1)),s.push(e+1+r*(this.numX+1)),s.push(e+1+(r+1)*(this.numX+1)),s.push(e+(r+1)*(this.numX+1));this.engine.setVertexArray(t,"aVertexPosition",i,s,2),t.clearColor=new n.Vec4(0,0,0,0),t.isDepthTest=!1,t.drawMode=this.engine.gl.TRIANGLES}update(){const t=this.bufferInput.width/this.bufferInput.height;this.engine.gl.uniformMatrix4fv(this.uProjectMatrix,!1,n.Mat4.perspectiveProjectMatrix(this.camera.viewAngle,t,.5,65e3).getArray()),this.engine.gl.uniformMatrix3fv(this.uTransformMatrixPrev,!1,this.camera.transformMatPrev.getArray()),this.engine.gl.uniformMatrix3fv(this.uTransformMatrix,!1,this.camera.transformMat.getArray()),this.engine.gl.uniform3fv(this.uPositionDelta,this.camera.positionDelta.getArray()),this.engine.gl.uniform1f(this.uCameraViewAngle,this.camera.viewAngle)}}},386:(t,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.ProgramB=void 0,r.ProgramB=class{constructor(t,r,e,n){this.engine=t,this.bufferInput=r,this.camera=e,this.atm=n}init(t,r){this.engine.setTextureWithMIP(t.program,"uTextureGrayNoise",r),this.engine.setRenderedTexture(t.program,this.bufferInput.fbTextures[0],"uTextureProgramA");const e=this.engine.gl.getUniformLocation(t.program,"uTextureAResolution");this.engine.gl.uniform2f(e,this.bufferInput.width,this.bufferInput.height),this.uCameraPosition=this.engine.gl.getUniformLocation(t.program,"uCameraPosition"),this.uCameraViewAngle=this.engine.gl.getUniformLocation(t.program,"uCameraViewAngle"),this.uCameraDirection=this.engine.gl.getUniformLocation(t.program,"uCameraDirection"),this.uTransformMat=this.engine.gl.getUniformLocation(t.program,"uTransformMat"),this.uPlanetRadius=this.engine.gl.getUniformLocation(t.program,"uPlanetRadius"),this.engine.gl.uniform1f(this.uPlanetRadius,this.atm.planetRadius),this.uPlanetCenter=this.engine.gl.getUniformLocation(t.program,"uPlanetCenter"),this.engine.gl.uniform3fv(this.uPlanetCenter,this.atm.planetCenter.getArray()),this.uScreenMode=this.engine.gl.getUniformLocation(t.program,"uScreenMode"),this.uMapScale=this.engine.gl.getUniformLocation(t.program,"uMapScale")}update(t,r){this.engine.gl.uniform3fv(this.uCameraPosition,this.camera.position.getArray()),this.engine.gl.uniform3fv(this.uCameraDirection,this.camera.direction.getArray()),this.engine.gl.uniformMatrix3fv(this.uTransformMat,!1,this.camera.transformMat.getArray()),this.engine.gl.uniform1f(this.uCameraViewAngle,this.camera.viewAngle),this.engine.gl.uniform2f(this.uScreenMode,this.camera.screenMode,this.camera.mapMode),this.engine.gl.uniform1f(this.uMapScale,this.camera.mapScale)}}},9:(t,r,e)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.ProgramRender=void 0;const n=e(193),i=e(764),s=e(24),o=e(921);r.ProgramRender=class{constructor(t,r,e,i,s,a,l,h){this.skyRefreshTime=0,this.numSSAOSamples=32,this.SSAOSamples=[],this.SSAONoise=[],this.numOfFlares=2,this.engine=t,this.shaderA=r,this.shaderB=e,this.camera=i,this.atm=s,this.sky=a,this.flare1=l,this.flare2=h;for(let t=0;t<this.numSSAOSamples;t++){let r=t/this.numSSAOSamples;r=(0,o.mix)(.1,1,r*r),this.SSAOSamples.push(new n.Vec3(2*Math.random()-1,2*Math.random()-1,Math.random()).normalizeMutable().mulMutable(r))}for(let t=0;t<16;t++)this.SSAONoise.push(new n.Vec3(2*Math.random()-1,2*Math.random()-1,0))}init(t,r,e,n,i){this.engine.setRenderedTexture(t.program,this.shaderA.fbTextures[0],"uTextureProgramA"),this.engine.setRenderedTexture(t.program,this.shaderB.fbTextures[0],"uNormalDepthProgramB"),this.engine.setRenderedTexture(t.program,this.shaderB.fbTextures[1],"uAlbedoProgramB"),this.engine.setTextureWithMIP(t.program,"uTextureGrayNoise",i);const o=this.shaderB.width,a=this.shaderB.height,l=this.engine.gl.getUniformLocation(t.program,"uTextureBResolution");this.engine.gl.uniform2f(l,o,a);const h=[];this.SSAONoise.forEach((t=>h.push(...t.getArray()))),this.engine.setTextureWithArray16F(t.program,"uTextureSSAONoise",4,4,new Float32Array(h)),this.engine.setTexture(t.program,"uTextureBlueNoise",r),this.engine.setTexture(t.program,"uTextureMilkyway",e),this.engine.setTexture(t.program,"uTextureConstellation",n),this.uSSAOSamples=this.engine.gl.getUniformLocation(t.program,"uSSAOSamples");const u=[];this.SSAOSamples.forEach((t=>u.push(...t.getArray()))),this.engine.gl.uniform3fv(this.uSSAOSamples,u),this.uCameraPosition=this.engine.gl.getUniformLocation(t.program,"uCameraPosition"),this.uCameraViewAngle=this.engine.gl.getUniformLocation(t.program,"uCameraViewAngle"),this.uTransformMat=this.engine.gl.getUniformLocation(t.program,"uTransformMat"),this.uCameraInShadow=this.engine.gl.getUniformLocation(t.program,"uCameraInShadow"),this.uSkyColor=this.engine.gl.getUniformLocation(t.program,"uSkyColor"),this.uSunDirection=this.engine.gl.getUniformLocation(t.program,"uSunDirection"),this.uSunDiscColor=this.engine.gl.getUniformLocation(t.program,"uSunDiscColor"),this.uMoonDirection=this.engine.gl.getUniformLocation(t.program,"uMoonDirection"),this.uMoonDiscColor=this.engine.gl.getUniformLocation(t.program,"uMoonDiscColor"),this.uSunDiscAngleSin=this.engine.gl.getUniformLocation(t.program,"uSunDiscAngleSin"),this.engine.gl.uniform1f(this.uSunDiscAngleSin,s.SUN_DISC_ANGLE_SIN),this.uBetaRayleigh=this.engine.gl.getUniformLocation(t.program,"uBetaRayleigh"),this.engine.gl.uniform3fv(this.uBetaRayleigh,this.atm.betaRayleigh.getArray()),this.uBetaMie=this.engine.gl.getUniformLocation(t.program,"uBetaMie"),this.engine.gl.uniform3fv(this.uBetaMie,this.atm.betaMie.getArray()),this.uGMie=this.engine.gl.getUniformLocation(t.program,"uGMie"),this.engine.gl.uniform1f(this.uGMie,this.atm.g),this.uScaleHeight=this.engine.gl.getUniformLocation(t.program,"uScaleHeight"),this.engine.gl.uniform2f(this.uScaleHeight,this.atm.heightRayleigh,this.atm.heightMie),this.uAtmRadius=this.engine.gl.getUniformLocation(t.program,"uAtmRadius"),this.engine.gl.uniform1f(this.uAtmRadius,this.atm.radius),this.uPlanetRadius=this.engine.gl.getUniformLocation(t.program,"uPlanetRadius"),this.engine.gl.uniform1f(this.uPlanetRadius,this.atm.planetRadius),this.uPlanetCenter=this.engine.gl.getUniformLocation(t.program,"uPlanetCenter"),this.engine.gl.uniform3fv(this.uPlanetCenter,this.atm.planetCenter.getArray()),this.uSkyTransformMat=this.engine.gl.getUniformLocation(t.program,"uSkyTransformMat"),this.uConstellationsColor=this.engine.gl.getUniformLocation(t.program,"uConstellationsColor"),this.uHeadLight=this.engine.gl.getUniformLocation(t.program,"uHeadLight"),this.uFlarePositions=this.engine.gl.getUniformLocation(t.program,"uFlarePositions"),this.uFlareLights=this.engine.gl.getUniformLocation(t.program,"uFlareLights"),this.uScreenMode=this.engine.gl.getUniformLocation(t.program,"uScreenMode"),this.uMapScale=this.engine.gl.getUniformLocation(t.program,"uMapScale")}update(t,r){this.engine.gl.uniform3fv(this.uCameraPosition,this.camera.position.getArray()),this.engine.gl.uniform1f(this.uCameraViewAngle,this.camera.viewAngle),this.engine.gl.uniformMatrix3fv(this.uTransformMat,!1,this.camera.transformMat.getArray()),this.engine.gl.uniformMatrix3fv(this.uSkyTransformMat,!1,this.sky.transformMat.getArray()),this.engine.gl.uniform1f(this.uConstellationsColor,this.sky.isShowConstellations?1:0);const e=this.camera.screenMode!=i.FRONT_VIEW?0:this.camera.inShadow(this.atm,this.camera.position,this.sky.sunDirection);this.engine.gl.uniform1f(this.uCameraInShadow,e),this.engine.gl.uniform3fv(this.uSunDiscColor,this.sky.sunDiscColor.getArray()),this.engine.gl.uniform3f(this.uHeadLight,this.camera.headLights,this.camera.headLights,this.camera.headLights),this.engine.gl.uniform3fv(this.uSunDirection,this.sky.sunDirection.getArray()),this.engine.gl.uniform3fv(this.uSunDiscColor,this.sky.sunDiscColor.getArray()),this.engine.gl.uniform3fv(this.uMoonDirection,this.sky.moonDirection.getArray()),this.engine.gl.uniform3fv(this.uMoonDiscColor,this.sky.moonDiskColor.getArray()),this.engine.gl.uniform3fv(this.uSkyColor,this.sky.skyColor.getArray());const s=[...this.flare1.position.getArray(),...this.flare2.position.getArray()];this.engine.gl.uniform3fv(this.uFlarePositions,s);const o=[this.flare1.isVisible?this.flare1.light:n.Vec3.ZERO(),this.flare2.isVisible?this.flare2.light:n.Vec3.ZERO()];this.engine.gl.uniform3fv(this.uFlareLights,[...o[0].getArray(),...o[1].getArray()]),this.engine.gl.uniform2f(this.uScreenMode,this.camera.screenMode,this.camera.mapMode),this.engine.gl.uniform1f(this.uMapScale,this.camera.mapScale)}}},460:(t,r)=>{Object.defineProperty(r,"__esModule",{value:!0}),r.loadImage=void 0,r.loadImage=function(t){return new Promise(((r,e)=>{const n=new Image;n.onload=()=>r(n),n.onerror=()=>e(),n.src=t}))}},844:(t,r,e)=>{e.r(r),e.d(r,{default:()=>n});const n="#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n/**\r\n * Шейдер для формирования буфера с данными глубины на основании\r\n * данных предыдущего кадра.\r\n * vTextureBData.w - значение глубины из вершинного шейдера.\r\n * Можно определять цвет из текстуры предыдущего кадра.\r\n */\r\n\r\n/** разрешение экрана */\r\nuniform vec2 uResolution;\r\n/** разрешение текстуры предыдущего кадра */\r\nuniform vec2 uTextureBResolution;\r\n\r\n/** текстура предыдущего кадра */\r\nuniform sampler2D uTextureProgramB;\r\n\r\nin vec4 vTextureBData;\r\n\r\nout vec4 fragColor;\r\n\r\nvoid main() {\r\n  vec2 uv = gl_FragCoord.xy/uResolution;\r\n  fragColor = vTextureBData;\r\n}\r\n "},937:(t,r,e)=>{e.r(r),e.d(r,{default:()=>n});const n="#version 300 es\r\n\r\n/**\r\n * Шейдер для формирования буфера с данными глубины на основании\r\n * данных предыдущего кадра.\r\n * vTextureBData.w - значение глубины из вершинного шейдера.\r\n * Можно определять цвет из текстуры предыдущего кадра.\r\n */\r\n\r\n/** Матрица проекции */\r\nuniform mat4 uProjectMatrix;\r\n/** Разрешение текстуры предыдущего кадра */\r\nuniform vec2 uTextureBResolution;\r\n/** Разрешение полигональной сетки моделирующей глубину кадра */\r\nuniform vec2 uNetResolution;\r\n/** Угол обзора камеры (по горизонтали) */\r\nuniform float uCameraViewAngle;\r\n/** Матрица трансформации предыдущего кадра */\r\nuniform mat3 uTransformMatrixPrev;\r\n/** Матрица трансформации текущего кадра */\r\nuniform mat3 uTransformMatrix;\r\n/** Смещение позиции камеры между кадрами */\r\nuniform vec3 uPositionDelta;\r\n\r\n/** Текстура предыдущего кадра */\r\nuniform sampler2D uTextureProgramB;\r\n\r\n/** Положение узла полигональной сетки моделирующей глубину кадра */\r\nin vec3 aVertexPosition;\r\n\r\n/** Данные по узлу сетки, vTextureBData.w - глубина узла */\r\nout vec4 vTextureBData;\r\n\r\nvoid main() {\r\n  vec2 duv = vec2(1.5)/uNetResolution;\r\n  vec2 uv = 0.5*(vec2(1.)+aVertexPosition.xy);\r\n  vec4 buf = texture(uTextureProgramB, uv);\r\n\r\n  // находим мнинмальную глубину по 9-ти точкам (коррекция на разрывах глубины)\r\n  float wmin = texture(uTextureProgramB, uv+vec2(duv.x, 0)).w;\r\n  wmin = min(wmin, texture(uTextureProgramB, uv-vec2(duv.x, 0)).w);\r\n  wmin = min(wmin, texture(uTextureProgramB, uv+vec2(0, duv.y)).w);\r\n  wmin = min(wmin, texture(uTextureProgramB, uv-vec2(0, duv.y)).w);\r\n\r\n  wmin = min(wmin, texture(uTextureProgramB, uv+vec2(duv.x, duv.y)).w);\r\n  wmin = min(wmin, texture(uTextureProgramB, uv+vec2(-duv.x, -duv.y)).w);\r\n  wmin = min(wmin, texture(uTextureProgramB, uv+vec2(duv.x, -duv.y)).w);\r\n  wmin = min(wmin, texture(uTextureProgramB, uv+vec2(-duv.x, duv.y)).w);\r\n\r\n  buf.w = min(buf.w, wmin);\r\n  vTextureBData = buf;\r\n\r\n  float t = tan(0.5*uCameraViewAngle);\r\n  vec3 rd = normalize(vec3(aVertexPosition.xy*uTextureBResolution*t/uTextureBResolution.x, -1.));\r\n  vec3 pos = rd*buf.w;\r\n\r\n  pos = pos*transpose(uTransformMatrixPrev);\r\n  pos = (pos - uPositionDelta)*uTransformMatrix;\r\n\r\n  vTextureBData.w = length(pos);\r\n\r\n  // при движении назад по краям устанавливаем глубину 0\r\n  vec3 deltaPos = uPositionDelta*uTransformMatrix;\r\n  if(deltaPos.z > 0. && (uv.y <= duv.y || uv.y >= 1.-duv.y || uv.x <= duv.x || uv.x >= 1.-duv.x)) vTextureBData.w = 0.;\r\n\r\n  gl_Position = uProjectMatrix*vec4(pos, 1);\r\n}\r\n"},256:(t,r,e)=>{e.r(r),e.d(r,{default:()=>n});const n="#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n/**\r\n * Шейдер формирования G-буфера ландшафта.\r\n * Используется предварительная карта глубины, построенная на основании предыдущего кадра.\r\n */\r\n\r\n/** Разрешение экрана */\r\nuniform vec2 uResolution;\r\n\r\n/** Текстура с предварительными данными глубины на основе предыдущего кадра */\r\nuniform sampler2D uTextureProgramA;\r\n\r\n/** Положение камеры */\r\nuniform vec3 uCameraPosition;\r\n/** Вектор направления камеры */\r\nuniform vec3 uCameraDirection;\r\n\r\n/** Синус половины углового размера солнца */\r\nuniform float uSunDiscAngleSin;\r\n/** Радиус планеты */\r\nuniform float uPlanetRadius;\r\n/** Положение центра планеты */\r\nuniform vec3 uPlanetCenter;\r\n\r\n/**\r\n * Режим отображения\r\n * x - режим экрана: \r\n *   FRONT_VIEW - вид камеры,\r\n *   MAP_VIEW - вид карты,\r\n *   DEPTH_VIEW - вид карты глубины (режим отключен)\r\n * y - опции отображения карты: \r\n *   MAP_ONLY - только карта,\r\n *   MAP_GRID - показывать сетку,\r\n *   MAP_HEIGHTS - показывать изолинии высот\r\n */\r\nuniform vec2 uScreenMode;\r\n/** Масштаб карты */\r\nuniform float uMapScale;\r\n\r\n/** Луч в системе координат планеты */\r\nin vec3 vRay;\r\n\r\n/** Буфер нормалей (xyz) и глубины (w) */\r\nlayout (location = 0) out vec4 gNormalDepth;\r\n/** Буфер значений альбедо */\r\nlayout (location = 1) out vec4 gAlbedo;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения констант\r\n// ----------------------------------------------------------------------------\r\n#ifndef CONST_MODULE\r\n#define CONST_MODULE\r\n\r\n// Просмотр ошибки карты глубины буфера A\r\n//#define DEPTH_ERROR_VIEW\r\n//#define SHADOWS_ITERATIONS_VIEW\r\n//#define SHADOW_DISTANCE_VIEW\r\n\r\n\r\n// Максимальная дальность отображения ландшафта\r\nconst float MAX_TERRAIN_DISTANCE = 30000.;\r\n// Mаксимальная высота ландшафта\r\nconst float MAX_TRN_ELEVATION = 1.8*1100.;//1.8*H_SCALE; \r\n\r\n// Интенсивность солнечного света\r\nconst vec3 LIGHT_INTENSITY = vec3(15.);\r\n\r\nconst float PI = 3.14159265358979323846;\r\n\r\n// View modes\r\nconst float FRONT_VIEW = 0.;\r\nconst float MAP_VIEW = 1.;\r\nconst float DEPTH_VIEW = 2.;\r\n// Map modes\r\nconst int MAP_ONLY = 0;\r\nconst int MAP_GRID = 1;\r\nconst int MAP_HEIGHTS = 2;\r\n\r\n\r\n#ifdef DEPTH_ERROR_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#ifdef RAYCAST_ITERATIONS_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#ifdef SHADOWS_ITERATIONS_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#ifdef SHADOW_DISTANCE_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций генерации ландшафта\r\n// ----------------------------------------------------------------------------\r\n#ifndef TERR_MODULE\r\n#define TERR_MODULE\r\n\r\n// ----------------------------------------------------------------------------\r\n// Генерация ландшафта\r\n// ----------------------------------------------------------------------------\r\nuniform sampler2D uTextureGrayNoise;\r\n\r\n// value noise, and its analytical derivatives\r\nvec3 noised(vec2 x) {\r\n  vec2 f = fract(x);\r\n  //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n  //vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n\r\n  vec2 p = floor(x);\r\n  float a = textureLod(uTextureGrayNoise, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n  float b = textureLod(uTextureGrayNoise, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n  float c = textureLod(uTextureGrayNoise, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n  float d = textureLod(uTextureGrayNoise, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\r\n  return vec3((a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y),\r\n               du*(u.yx*(a-b-c+d) + vec2(b,c) - a));\r\n}\r\n\r\nconst mat2 im2 = mat2(0.8,-0.6,0.6,0.8);\r\nconst float W_SCALE = 3000.; // масштаб по горизонтали\r\nconst float H_SCALE = 1100.; // масштаб по высоте\r\n//const float MAX_TRN_ELEVATION = 1.8*H_SCALE; // максимальная высота\r\nconst float GRASS_HEIGHT_MAX = 600.;\r\nconst float SEA_LEVEL = 0.;\r\n\r\n// Генерация высоты с эррозией без производных упрощенная\r\nfloat terrainH(vec2 x) {\r\n  vec2  p = x/W_SCALE;\r\n  float a = 0.0;\r\n  float b = 1.0;\r\n  vec2  d = vec2(0.0);\r\n  for( int i=0; i<16; i++ ) {\r\n    vec3 n = noised(p);\r\n    float flatland = 1.;//clamp((n.x*H_SCALE-300.)/(GRASS_HEIGHT_MAX-300.),0.,1.);\r\n    flatland *= flatland;\r\n    d += n.yz; a += flatland*b*n.x/(1.+dot(d,d));\r\n    b *= 0.5; p = im2*p*2.0;\r\n  }\r\n  return max(H_SCALE*a,SEA_LEVEL);\r\n}\r\nfloat terrainM(vec2 x) {\r\n  vec2  p = x/W_SCALE;\r\n  float a = 0.0;\r\n  float b = 1.0;\r\n  vec2  d = vec2(0.0);\r\n  for( int i=0; i<9; i++ ) {\r\n    vec3 n = noised(p);\r\n    float flatland = 1.;//clamp((n.x*H_SCALE-300.)/(GRASS_HEIGHT_MAX-300.),0.,1.);\r\n    flatland *= flatland;\r\n    d += n.yz; a += flatland*b*n.x/(1.+dot(d,d));\r\n    b *= 0.5; p = im2*p*2.0;\r\n  }\r\n  return max(H_SCALE*a,SEA_LEVEL);\r\n}\r\nfloat terrainS(vec2 x) {\r\n  vec2  p = x/W_SCALE;\r\n  float a = 0.0;\r\n  float b = 1.0;\r\n  vec2  d = vec2(0.0);\r\n  for( int i=0; i<5; i++ ) {\r\n    vec3 n = noised(p);\r\n    float flatland = 1.;//clamp((n.x*H_SCALE-300.)/(GRASS_HEIGHT_MAX-300.),0.,1.);\r\n    flatland *= flatland;\r\n    d += n.yz; a += flatland*b*n.x/(1.+dot(d,d));\r\n    b *= 0.5; p = im2*p*2.0;\r\n  }\r\n  return max(H_SCALE*a,SEA_LEVEL);\r\n}\r\n\r\nvec3 calcNormalH(vec3 pos, float t) {\r\n  vec2 eps = vec2(0.001*t, 0.0);\r\n  return normalize(vec3(\r\n    terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\r\n    2.0*eps.x,\r\n    terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx)\r\n  ));\r\n}\r\n\r\nvec3 calcNormalM(vec3 pos, float t) {\r\n  vec2 eps = vec2(0.001*t, 0.0);\r\n  return normalize(vec3(\r\n    terrainM(pos.xz-eps.xy) - terrainM(pos.xz+eps.xy),\r\n    2.0*eps.x,\r\n    terrainM(pos.xz-eps.yx) - terrainM(pos.xz+eps.yx)\r\n  ));\r\n}\r\n\r\n// функция определения затененности\r\nfloat softShadow(vec3 ro, vec3 rd, float dis, out int i, out float t) {\r\n  float minStep = clamp(0.01*dis,10.,500.);\r\n  float cosA = sqrt(1.-rd.z*rd.z); // косинус угла наклона луча от камеры к горизонтали\r\n\r\n  float res = 1.;\r\n  t = 0.01*dis;\r\n  for(i=0; i<200; i++) { // меньшее кол-во циклов приводит к проблескам в тени\r\n\t  vec3 p = ro + t*rd;\r\n    if(p.y>MAX_TRN_ELEVATION) return smoothstep(-uSunDiscAngleSin, uSunDiscAngleSin, res);\r\n    float h = p.y - terrainS(p.xz);\r\n\t  res = min(res, cosA*h/t);\r\n    if(res<-uSunDiscAngleSin) return smoothstep(-uSunDiscAngleSin, uSunDiscAngleSin, res);\r\n    t += max(minStep, abs(0.7*h)); // коэффициент устраняет полосатость при плавном переходе тени\r\n  }\r\n  return 0.;\r\n}\r\n\r\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\r\nfloat fbm(vec2 p) {\r\n  float f = 0.0;\r\n  f += 0.5000*texture(uTextureGrayNoise, p/256.0 ).x; p = m2*p*2.02;\r\n  f += 0.2500*texture(uTextureGrayNoise, p/256.0 ).x; p = m2*p*2.03;\r\n  f += 0.1250*texture(uTextureGrayNoise, p/256.0 ).x; p = m2*p*2.01;\r\n  f += 0.0625*texture(uTextureGrayNoise, p/256.0 ).x;\r\n  return f/0.9375;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Материалы\r\n// ----------------------------------------------------------------------------\r\n\r\n// rgb - альбедо, a - зарезервировано\r\n//vec4 grassAlbedo = 5.*vec4(0.042, 0.042, 0.015, 1.); \r\nvec4 grassAlbedo = vec4(pow(vec3(0.23529411765, 0.21568627451, 0.14313725490), vec3(2.2)), 1.);\r\nvec4 grassAlbedo2 = vec4(pow(vec3(0.2498, 0.2509, 0.1176), vec3(2.2)), 1.);\r\n//vec4 grassAlbedo = vec4(0.27, 0.21, 0.09, 1.);\r\n//vec4 darkRockAlbedo = 5.*vec4(0.072, 0.045, 0.027, 1.);\r\n//vec4 lightRockAlbedo = 5.*vec4(0.09, 0.081, 0.072, 1.);\r\nvec4 lightRockAlbedo = vec4(0.6*pow(vec3(0.5725, 0.4667, 0.4392), vec3(2.2)), 1.);\r\nvec4 darkRockAlbedo = vec4(0.8*pow(vec3(0.3843, 0.2901, 0.2784), vec3(2.2)), 1.);\r\n//vec4 sandAlbedo = 5.*1.7*vec4(0.09, 0.081, 0.072, 1.);\r\nvec4 sandAlbedo = vec4(pow(vec3(0.59607843137, 0.50588235294, 0.49803921569), vec3(2.2)), 1.);\r\n\r\nvec4 darkSandAlbedo = vec4(0.4*pow(vec3(0.43137254902, 0.34117647059, 0.360784313737), vec3(2.2)), 1.);//5.*vec4(0.030, 0.022, 0.010, 1.);\r\n//vec4 snowAlbedo = 5.*vec4(0.1798, 0.1885, 0.203, 1.);\r\n\r\n//vec4 grassAlbedo = vec4(0.158, 0.158, 0.053, 1.);\r\n//vec4 grassAlbedo = vec4(0.27, 0.21, 0.09, 1.);\r\n//vec4 darkRockAlbedo = vec4(0.252, 0.158, 0.095, 1.);\r\n//vec4 lightRockAlbedo = vec4(0.315, 0.284, 0.252, 1.);\r\n//vec4 sandAlbedo = vec4(0.252, 0.158, 0.095, 1.);\r\n//vec4 sandAlbedo = vec4(0.585, 0.482, 0.428, 1.);\r\n//vec4 darkSandAlbedo = vec4(0.150, 0.110, 0.050, 1.);\r\n//vec4 snowAlbedo = vec4(0.750, 0.940, 1.00, 1.);\r\nvec4 snowAlbedo = vec4(0.75, 0.80, 0.85, 1.);\r\n\r\n// определение цвета пикселя\r\nvec4 terrain_color(vec3 pos, vec3 nor) {\r\n  float LvsR = 1.;//step(0.5, gl_FragCoord.x/uResolution.x);\r\n\r\n  // мелкий шум в текстуре\r\n  float r = texture(uTextureGrayNoise, 400.0*pos.xz/W_SCALE ).x;\r\n  r = mix(1., 0.5+0.5*r, LvsR);\r\n  // мелкие и крупные пятна на скалах и траве\r\n  float r2 = sqrt(fbm(pos.xz*1.1)*fbm(pos.xz*0.5));\r\n  r2 = mix(1., r2, LvsR);\r\n  // полосы на скалах\r\n  vec4 albedo =(1.+0.*r2)*(r*0.25+1.)*mix(darkRockAlbedo, lightRockAlbedo,\r\n                 texture(uTextureGrayNoise, vec2(0.1*pos.x/W_SCALE,0.2*pos.y/H_SCALE)).x*r2);\r\n\r\n  // песок\r\n  float sh = smoothstep(500.,600.,pos.y); // фактор высоты\r\n  float sn = smoothstep(0.7, 0.9, nor.y); // фактор наклона поверхности\r\n  albedo = mix(albedo, sandAlbedo*(0.5+0.5*r), sn*sh);\r\n\r\n  // земля\r\n  float dh = 1.-smoothstep(500.,650.,pos.y); // фактор высоты\r\n  float dn = smoothstep(0.5, 1., nor.y); // фактор наклона поверхности\r\n  albedo = mix(albedo, r2*darkSandAlbedo*(0.5+0.5*r), dn*dh);\r\n\r\n  // трава\r\n  float gh = 1.-smoothstep(400.,600.,pos.y); // фактор высоты\r\n  float gn = smoothstep(0.6, 1.0, nor.y); // фактор наклона поверхности\r\n  albedo = mix(albedo, (0.25+0.75*r)*mix(grassAlbedo,grassAlbedo2,r2), step(0.6, gh*gn));\r\n  //albedo = mix(albedo, r2*grassAlbedo*(0.25+0.75*r), gh*gn);\r\n  \r\n  // снег на высоте от 800 м \r\n  float h = smoothstep(800., 1000., pos.y + 250.*fbm(pos.xz/W_SCALE));\r\n  // угол уклона\r\n  float e = smoothstep(1.-0.5*h, 1.-0.1*h, nor.y);\r\n  // северное направление\r\n  float o = 0.3 + 0.7*smoothstep(0., 0.1, -nor.z+h*h);\r\n  float s = h*e*o;\r\n  albedo = mix(albedo, snowAlbedo, smoothstep(0.1, 0.9, s));\r\n  return vec4(albedo.rgb, 1.);\r\n}\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций отображения карты\r\n// ----------------------------------------------------------------------------\r\n#ifndef MAP_MODULE\r\n#define MAP_MODULE\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций отображения карты\r\n// ----------------------------------------------------------------------------\r\n\r\nfloat grid(float x, float st) {\r\n  float s = 2.*x/st;\r\n  float a = fract(s);\r\n  s = floor(mod(s,2.));\r\n  return pow(mix(a,1.-a,s),.2);\r\n}\r\n\r\nvec2 grid(vec2 x, float st) {\r\n  vec2 s = 2.*x/st;\r\n  vec2 a = fract(s);\r\n  s = floor(mod(s,2.));\r\n  return mix(a,1.-a,s);\r\n}\r\n\r\n// pos - положение камеры\r\n// camdir - направление камеры\r\nvec3 showMap(vec3 pos, vec2 camdir, vec2 uv, int mode, out vec4 norDepth) {\r\n  vec2 p = pos.xz + vec2(1,-1)*uMapScale*uv;\r\n  float h = terrainM(p);\r\n  vec3 nor = calcNormalH(vec3(p.x,h,p.y), 500.);\r\n  norDepth = vec4(nor, MAX_TRN_ELEVATION-h);\r\n  vec4 albedo = terrain_color(vec3(p.x,h,p.y), nor);\r\n  vec3 col = albedo.rgb;//vec3(0.5+0.5*dot(nor.xyz,normalize(vec3(-1,1,-1))))*albedo.rgb;\r\n  // положение камеры\r\n  col *= smoothstep(.01,0.012,length(pos.xz-p)/uMapScale);\r\n  // направление камеры\r\n  vec2 rp = pos.xz-p;\r\n  col *= dot(rp,camdir)<0. ? smoothstep(0.0,0.002,abs(camdir.x*rp.y-camdir.y*rp.x)/uMapScale) : 1.;\r\n  if((mode & MAP_GRID)!=0) {\r\n    // координатная сетка, по 500м на линию\r\n    vec2 gr = smoothstep(0.,0.06, grid(p,500.));\r\n    col *= gr.x*gr.y;\r\n  }\r\n  // уровни высот, по 50м на уровень\r\n  col *= (mode & MAP_HEIGHTS)!=0 ? smoothstep(0.,1., grid(h,50.)) : 1.;\r\n  return col;\r\n}\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Формирование G-буфера\r\n// ----------------------------------------------------------------------------\r\n\r\n/** \r\n * Рейкастинг для случая плоской поверхности планеты\r\n *   ro - положение камеры\r\n *   rd - направление луча из камеры\r\n *   tmin - начальное глубина рейтрейсинга\r\n *   tmax - максимальная глубина рейтрейсинга\r\n *   i - выходное значение количества циклов рейтрейсинга\r\n */\r\nfloat raycast(vec3 ro, vec3 rd, float tmin, float tmax, out int i) {\r\n  float t = tmin;\r\n  float d = ro.y - MAX_TRN_ELEVATION;\r\n  if(d >= 0.) t = clamp(-d/rd.y, t, tmax); // поиск стартовой точки, если камера выше поверхности максимальной высоты гор\r\n\r\n  for(i=0; i<300; i++) {\r\n    vec3 pos = ro + t*rd;\r\n    if(pos.y>ro.y && pos.y>MAX_TRN_ELEVATION) return tmax + 1.;\r\n    float h = pos.y - terrainM(pos.xz);\r\n    if( abs(h)<(0.003*t) || t>tmax ) break; // двоятся детали при большем значении\r\n    t += 0.4*h; // на тонких краях могут быть артефакты при большом коэффициенте\r\n  }\r\n  return t;\r\n}\r\n\r\n/** \r\n * Рейкастинг для случая сферической поверхности планеты \r\n *   ro - положение камеры\r\n *   rd - направление луча из камеры\r\n *   tmin - начальное глубина рейтрейсинга\r\n *   tmax - максимальная глубина рейтрейсинга\r\n *   i - выходное значение количества циклов рейтрейсинга\r\n */\r\nfloat raycastSpheric(vec3 ro, vec3 rd, float tmin, float tmax, out int i) {\r\n  float t = tmin;\r\n  /*\r\n  НЕОБХОДИМО ПЕРЕРАБОТАТЬ\r\n  float d = ro.y - MAX_TRN_ELEVATION;\r\n  if(d >= 0.) t = clamp(-d/rd.y, 0., tmax); // поиск стартовой точки, если камера выше поверхности максимальной высоты гор\r\n\r\n  for(int i=0; i<300; i++) {\r\n    vec3 pos = ro + t*rd;\r\n    if(pos.y>ro.y && pos.y>MAX_TRN_ELEVATION) return tmax + 1.;\r\n    float h = pos.y - terrainM(pos.xz);\r\n    if( abs(h)<(0.003*t) || t>tmax ) break; // двоятся детали при большем значении\r\n    t += 0.4*h; // на тонких краях могут быть артефакты при большом коэффициенте\r\n  }\r\n  */\r\n  return t;\r\n}\r\n\r\nvoid main(void) {\r\n  vec2 uv = (gl_FragCoord.xy - 0.5*uResolution.xy)/uResolution.x;\r\n  vec3 rd = normalize(vRay);\r\n\r\n  if(uScreenMode.x == MAP_VIEW) {\r\n    // Режим отображения карты\r\n    vec4 norDepth;\r\n    gAlbedo = vec4(showMap(uCameraPosition, uCameraDirection.xz, uv, int(uScreenMode.y), norDepth), 1);\r\n    gNormalDepth = norDepth;\r\n  }\r\n  else {\r\n    #ifdef DEPTH_ERROR_VIEW\r\n    // Режим для просмотра ошибки глубины между расчетным значением и предсказанием на основе предыдущего кадра\r\n    float t0 = 1.;\r\n    #else\r\n    // Нормальный режим, с испльзованием данных предыдущего кадра\r\n    float t0 = texture(uTextureProgramA, gl_FragCoord.xy/uResolution).w;\r\n    #endif\r\n\r\n    vec3 col = vec3(0);\r\n    int raycastIterations = 0;\r\n    float t = 2.*MAX_TERRAIN_DISTANCE;\r\n    vec3 pos = uCameraPosition + t*rd;\r\n    if(t0 > MAX_TERRAIN_DISTANCE) {\r\n      gNormalDepth = vec4(-rd, t);\r\n    }\r\n    else {\r\n      t = raycast(uCameraPosition, rd, t0, MAX_TERRAIN_DISTANCE, raycastIterations);\r\n      if(t > MAX_TERRAIN_DISTANCE) {\r\n        gNormalDepth = vec4(-rd, 2.*MAX_TERRAIN_DISTANCE);\r\n      }\r\n      else {\r\n        pos = uCameraPosition + t*rd;\r\n        vec3 nor = calcNormalH(pos, max(200.,t));\r\n        gNormalDepth = vec4(nor, t);\r\n        col = terrain_color(pos, nor).rgb;\r\n      }\r\n    }\r\n\r\n    #ifdef RAYCAST_ITERATIONS_VIEW\r\n    // Для вывода числа итераций рейтрейсинга\r\n    col = vec3(raycastIterations)/300.;\r\n    #endif\r\n    gAlbedo = vec4(col, 1);\r\n  }\r\n}\r\n "},23:(t,r,e)=>{e.r(r),e.d(r,{default:()=>n});const n="#version 300 es\r\n\r\n/**\r\n * Шейдер рендеринга ландшафта.\r\n * Используется предварительная карта глубины, построенная на основании предыдущего кадра.\r\n */\r\n\r\n/** Матрица вращения камеры */\r\nuniform mat3 uTransformMat;\r\n/** Угол обзора камеры по горизонтали */\r\nuniform mediump float uCameraViewAngle;\r\n/** Разрешение фреймбуфера */\r\nuniform mediump vec2 uResolution;\r\n\r\nin vec3 aVertexPosition;\r\n\r\n/** Лучи в системе координат планеты */\r\nout vec3 vRay;\r\n\r\nvoid main(void) {\r\n  gl_Position = vec4(aVertexPosition, 1.0);\r\n  float t = tan(0.5*uCameraViewAngle);\r\n  vRay = uTransformMat*vec3(aVertexPosition.xy*uResolution*t/uResolution.x, -1.);\r\n}\r\n"},125:(t,r,e)=>{e.r(r),e.d(r,{default:()=>n});const n="#version 300 es\r\n\r\nprecision mediump float;\r\n\r\n/** Разрешение экрана */\r\nuniform vec2 uResolution;\r\nuniform vec2 uTime;\r\n\r\n/** \r\n * Насколько камера попадает под солнце:\r\n * 1. - полностью на солнце, 0. - полностью в тени\r\n */\r\nuniform float uCameraInShadow;\r\n/** Синус половины углового размера солнца */\r\nuniform float uSunDiscAngleSin;\r\n/** Направление на солнце */\r\nuniform vec3 uSunDirection;\r\n/** Цвет и интенсивность света от солнца */\r\nuniform vec3 uSunDiscColor;\r\n/** Направление на луну */\r\nuniform vec3 uMoonDirection;\r\n/** Цвет и интенсивность света от луны */\r\nuniform vec3 uMoonDiscColor;\r\n/** Цвет и интенсивность света неба */\r\nuniform vec3 uSkyColor;\r\n\r\n/** Положение камеры */\r\nuniform vec3 uCameraPosition;\r\n\r\n/** Цвет и интенсивность света фар: vec3(0.) - выключен */\r\nuniform vec3 uHeadLight;\r\n\r\n/** Положение сигнальных ракет */\r\nuniform vec3 uFlarePositions[2];\r\n/** Цвет и интенсивность света сигнальных ракет */\r\nuniform vec3 uFlareLights[2];\r\n\r\n/** Текстура программы A */\r\nuniform sampler2D uTextureProgramA;\r\n/** Нормали и глубина */\r\nuniform sampler2D uNormalDepthProgramB;\r\n/** Значения альбедо */\r\nuniform sampler2D uAlbedoProgramB;\r\n\r\nuniform vec2 uTextureBResolution;\r\nuniform sampler2D uTextureBlueNoise;\r\n\r\nuniform sampler2D uTextureSSAONoise;\r\n\r\n/** Луч в системе координат планеты */\r\nin vec3 vRay;\r\nin vec3 vRaySky;\r\nin vec3 vRayScreen;\r\nin mat3 vInverseTransformMat;\r\nin float vAspect;\r\nin float vAspectB;\r\n\r\n/**\r\n * Режим отображения\r\n * x - режим экрана: \r\n *   FRONT_VIEW - вид камеры,\r\n *   MAP_VIEW - вид карты,\r\n *   DEPTH_VIEW - вид карты глубины (режим отключен)\r\n * y - опции отображения карты: \r\n *   MAP_ONLY - только карта,\r\n *   MAP_GRID - показывать сетку,\r\n *   MAP_HEIGHTS - показывать изолинии высот\r\n */\r\nuniform vec2 uScreenMode;\r\n/** Масштаб карты */\r\nuniform float uMapScale;\r\n\r\nout vec4 fragColor;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения констант\r\n// ----------------------------------------------------------------------------\r\n#ifndef CONST_MODULE\r\n#define CONST_MODULE\r\n\r\n// Просмотр ошибки карты глубины буфера A\r\n//#define DEPTH_ERROR_VIEW\r\n//#define SHADOWS_ITERATIONS_VIEW\r\n//#define SHADOW_DISTANCE_VIEW\r\n\r\n\r\n// Максимальная дальность отображения ландшафта\r\nconst float MAX_TERRAIN_DISTANCE = 30000.;\r\n// Mаксимальная высота ландшафта\r\nconst float MAX_TRN_ELEVATION = 1.8*1100.;//1.8*H_SCALE; \r\n\r\n// Интенсивность солнечного света\r\nconst vec3 LIGHT_INTENSITY = vec3(15.);\r\n\r\nconst float PI = 3.14159265358979323846;\r\n\r\n// View modes\r\nconst float FRONT_VIEW = 0.;\r\nconst float MAP_VIEW = 1.;\r\nconst float DEPTH_VIEW = 2.;\r\n// Map modes\r\nconst int MAP_ONLY = 0;\r\nconst int MAP_GRID = 1;\r\nconst int MAP_HEIGHTS = 2;\r\n\r\n\r\n#ifdef DEPTH_ERROR_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#ifdef RAYCAST_ITERATIONS_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#ifdef SHADOWS_ITERATIONS_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#ifdef SHADOW_DISTANCE_VIEW\r\n#define TEST_VIEW\r\n#endif\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций генерации ландшафта\r\n// ----------------------------------------------------------------------------\r\n#ifndef TERR_MODULE\r\n#define TERR_MODULE\r\n\r\n// ----------------------------------------------------------------------------\r\n// Генерация ландшафта\r\n// ----------------------------------------------------------------------------\r\nuniform sampler2D uTextureGrayNoise;\r\n\r\n// value noise, and its analytical derivatives\r\nvec3 noised(vec2 x) {\r\n  vec2 f = fract(x);\r\n  //vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\r\n  //vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\r\n    vec2 u = f*f*(3.0-2.0*f);\r\n    vec2 du = 6.0*f*(1.0-f);\r\n\r\n  vec2 p = floor(x);\r\n  float a = textureLod(uTextureGrayNoise, (p+vec2(0.5,0.5))/256.0, 0.0 ).x;\r\n  float b = textureLod(uTextureGrayNoise, (p+vec2(1.5,0.5))/256.0, 0.0 ).x;\r\n  float c = textureLod(uTextureGrayNoise, (p+vec2(0.5,1.5))/256.0, 0.0 ).x;\r\n  float d = textureLod(uTextureGrayNoise, (p+vec2(1.5,1.5))/256.0, 0.0 ).x;\r\n\r\n  return vec3((a+(b-a)*u.x+(c-a)*u.y+(a-b-c+d)*u.x*u.y),\r\n               du*(u.yx*(a-b-c+d) + vec2(b,c) - a));\r\n}\r\n\r\nconst mat2 im2 = mat2(0.8,-0.6,0.6,0.8);\r\nconst float W_SCALE = 3000.; // масштаб по горизонтали\r\nconst float H_SCALE = 1100.; // масштаб по высоте\r\n//const float MAX_TRN_ELEVATION = 1.8*H_SCALE; // максимальная высота\r\nconst float GRASS_HEIGHT_MAX = 600.;\r\nconst float SEA_LEVEL = 0.;\r\n\r\n// Генерация высоты с эррозией без производных упрощенная\r\nfloat terrainH(vec2 x) {\r\n  vec2  p = x/W_SCALE;\r\n  float a = 0.0;\r\n  float b = 1.0;\r\n  vec2  d = vec2(0.0);\r\n  for( int i=0; i<16; i++ ) {\r\n    vec3 n = noised(p);\r\n    float flatland = 1.;//clamp((n.x*H_SCALE-300.)/(GRASS_HEIGHT_MAX-300.),0.,1.);\r\n    flatland *= flatland;\r\n    d += n.yz; a += flatland*b*n.x/(1.+dot(d,d));\r\n    b *= 0.5; p = im2*p*2.0;\r\n  }\r\n  return max(H_SCALE*a,SEA_LEVEL);\r\n}\r\nfloat terrainM(vec2 x) {\r\n  vec2  p = x/W_SCALE;\r\n  float a = 0.0;\r\n  float b = 1.0;\r\n  vec2  d = vec2(0.0);\r\n  for( int i=0; i<9; i++ ) {\r\n    vec3 n = noised(p);\r\n    float flatland = 1.;//clamp((n.x*H_SCALE-300.)/(GRASS_HEIGHT_MAX-300.),0.,1.);\r\n    flatland *= flatland;\r\n    d += n.yz; a += flatland*b*n.x/(1.+dot(d,d));\r\n    b *= 0.5; p = im2*p*2.0;\r\n  }\r\n  return max(H_SCALE*a,SEA_LEVEL);\r\n}\r\nfloat terrainS(vec2 x) {\r\n  vec2  p = x/W_SCALE;\r\n  float a = 0.0;\r\n  float b = 1.0;\r\n  vec2  d = vec2(0.0);\r\n  for( int i=0; i<5; i++ ) {\r\n    vec3 n = noised(p);\r\n    float flatland = 1.;//clamp((n.x*H_SCALE-300.)/(GRASS_HEIGHT_MAX-300.),0.,1.);\r\n    flatland *= flatland;\r\n    d += n.yz; a += flatland*b*n.x/(1.+dot(d,d));\r\n    b *= 0.5; p = im2*p*2.0;\r\n  }\r\n  return max(H_SCALE*a,SEA_LEVEL);\r\n}\r\n\r\nvec3 calcNormalH(vec3 pos, float t) {\r\n  vec2 eps = vec2(0.001*t, 0.0);\r\n  return normalize(vec3(\r\n    terrainH(pos.xz-eps.xy) - terrainH(pos.xz+eps.xy),\r\n    2.0*eps.x,\r\n    terrainH(pos.xz-eps.yx) - terrainH(pos.xz+eps.yx)\r\n  ));\r\n}\r\n\r\nvec3 calcNormalM(vec3 pos, float t) {\r\n  vec2 eps = vec2(0.001*t, 0.0);\r\n  return normalize(vec3(\r\n    terrainM(pos.xz-eps.xy) - terrainM(pos.xz+eps.xy),\r\n    2.0*eps.x,\r\n    terrainM(pos.xz-eps.yx) - terrainM(pos.xz+eps.yx)\r\n  ));\r\n}\r\n\r\n// функция определения затененности\r\nfloat softShadow(vec3 ro, vec3 rd, float dis, out int i, out float t) {\r\n  float minStep = clamp(0.01*dis,10.,500.);\r\n  float cosA = sqrt(1.-rd.z*rd.z); // косинус угла наклона луча от камеры к горизонтали\r\n\r\n  float res = 1.;\r\n  t = 0.01*dis;\r\n  for(i=0; i<200; i++) { // меньшее кол-во циклов приводит к проблескам в тени\r\n\t  vec3 p = ro + t*rd;\r\n    if(p.y>MAX_TRN_ELEVATION) return smoothstep(-uSunDiscAngleSin, uSunDiscAngleSin, res);\r\n    float h = p.y - terrainS(p.xz);\r\n\t  res = min(res, cosA*h/t);\r\n    if(res<-uSunDiscAngleSin) return smoothstep(-uSunDiscAngleSin, uSunDiscAngleSin, res);\r\n    t += max(minStep, abs(0.7*h)); // коэффициент устраняет полосатость при плавном переходе тени\r\n  }\r\n  return 0.;\r\n}\r\n\r\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\r\nfloat fbm(vec2 p) {\r\n  float f = 0.0;\r\n  f += 0.5000*texture(uTextureGrayNoise, p/256.0 ).x; p = m2*p*2.02;\r\n  f += 0.2500*texture(uTextureGrayNoise, p/256.0 ).x; p = m2*p*2.03;\r\n  f += 0.1250*texture(uTextureGrayNoise, p/256.0 ).x; p = m2*p*2.01;\r\n  f += 0.0625*texture(uTextureGrayNoise, p/256.0 ).x;\r\n  return f/0.9375;\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Материалы\r\n// ----------------------------------------------------------------------------\r\n\r\n// rgb - альбедо, a - зарезервировано\r\n//vec4 grassAlbedo = 5.*vec4(0.042, 0.042, 0.015, 1.); \r\nvec4 grassAlbedo = vec4(pow(vec3(0.23529411765, 0.21568627451, 0.14313725490), vec3(2.2)), 1.);\r\nvec4 grassAlbedo2 = vec4(pow(vec3(0.2498, 0.2509, 0.1176), vec3(2.2)), 1.);\r\n//vec4 grassAlbedo = vec4(0.27, 0.21, 0.09, 1.);\r\n//vec4 darkRockAlbedo = 5.*vec4(0.072, 0.045, 0.027, 1.);\r\n//vec4 lightRockAlbedo = 5.*vec4(0.09, 0.081, 0.072, 1.);\r\nvec4 lightRockAlbedo = vec4(0.6*pow(vec3(0.5725, 0.4667, 0.4392), vec3(2.2)), 1.);\r\nvec4 darkRockAlbedo = vec4(0.8*pow(vec3(0.3843, 0.2901, 0.2784), vec3(2.2)), 1.);\r\n//vec4 sandAlbedo = 5.*1.7*vec4(0.09, 0.081, 0.072, 1.);\r\nvec4 sandAlbedo = vec4(pow(vec3(0.59607843137, 0.50588235294, 0.49803921569), vec3(2.2)), 1.);\r\n\r\nvec4 darkSandAlbedo = vec4(0.4*pow(vec3(0.43137254902, 0.34117647059, 0.360784313737), vec3(2.2)), 1.);//5.*vec4(0.030, 0.022, 0.010, 1.);\r\n//vec4 snowAlbedo = 5.*vec4(0.1798, 0.1885, 0.203, 1.);\r\n\r\n//vec4 grassAlbedo = vec4(0.158, 0.158, 0.053, 1.);\r\n//vec4 grassAlbedo = vec4(0.27, 0.21, 0.09, 1.);\r\n//vec4 darkRockAlbedo = vec4(0.252, 0.158, 0.095, 1.);\r\n//vec4 lightRockAlbedo = vec4(0.315, 0.284, 0.252, 1.);\r\n//vec4 sandAlbedo = vec4(0.252, 0.158, 0.095, 1.);\r\n//vec4 sandAlbedo = vec4(0.585, 0.482, 0.428, 1.);\r\n//vec4 darkSandAlbedo = vec4(0.150, 0.110, 0.050, 1.);\r\n//vec4 snowAlbedo = vec4(0.750, 0.940, 1.00, 1.);\r\nvec4 snowAlbedo = vec4(0.75, 0.80, 0.85, 1.);\r\n\r\n// определение цвета пикселя\r\nvec4 terrain_color(vec3 pos, vec3 nor) {\r\n  float LvsR = 1.;//step(0.5, gl_FragCoord.x/uResolution.x);\r\n\r\n  // мелкий шум в текстуре\r\n  float r = texture(uTextureGrayNoise, 400.0*pos.xz/W_SCALE ).x;\r\n  r = mix(1., 0.5+0.5*r, LvsR);\r\n  // мелкие и крупные пятна на скалах и траве\r\n  float r2 = sqrt(fbm(pos.xz*1.1)*fbm(pos.xz*0.5));\r\n  r2 = mix(1., r2, LvsR);\r\n  // полосы на скалах\r\n  vec4 albedo =(1.+0.*r2)*(r*0.25+1.)*mix(darkRockAlbedo, lightRockAlbedo,\r\n                 texture(uTextureGrayNoise, vec2(0.1*pos.x/W_SCALE,0.2*pos.y/H_SCALE)).x*r2);\r\n\r\n  // песок\r\n  float sh = smoothstep(500.,600.,pos.y); // фактор высоты\r\n  float sn = smoothstep(0.7, 0.9, nor.y); // фактор наклона поверхности\r\n  albedo = mix(albedo, sandAlbedo*(0.5+0.5*r), sn*sh);\r\n\r\n  // земля\r\n  float dh = 1.-smoothstep(500.,650.,pos.y); // фактор высоты\r\n  float dn = smoothstep(0.5, 1., nor.y); // фактор наклона поверхности\r\n  albedo = mix(albedo, r2*darkSandAlbedo*(0.5+0.5*r), dn*dh);\r\n\r\n  // трава\r\n  float gh = 1.-smoothstep(400.,600.,pos.y); // фактор высоты\r\n  float gn = smoothstep(0.6, 1.0, nor.y); // фактор наклона поверхности\r\n  albedo = mix(albedo, (0.25+0.75*r)*mix(grassAlbedo,grassAlbedo2,r2), step(0.6, gh*gn));\r\n  //albedo = mix(albedo, r2*grassAlbedo*(0.25+0.75*r), gh*gn);\r\n  \r\n  // снег на высоте от 800 м \r\n  float h = smoothstep(800., 1000., pos.y + 250.*fbm(pos.xz/W_SCALE));\r\n  // угол уклона\r\n  float e = smoothstep(1.-0.5*h, 1.-0.1*h, nor.y);\r\n  // северное направление\r\n  float o = 0.3 + 0.7*smoothstep(0., 0.1, -nor.z+h*h);\r\n  float s = h*e*o;\r\n  albedo = mix(albedo, snowAlbedo, smoothstep(0.1, 0.9, s));\r\n  return vec4(albedo.rgb, 1.);\r\n}\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций расчета затенения окружающего освещения\r\n// ----------------------------------------------------------------------------\r\n#ifndef SSAO_MODULE\r\n#define SSAO_MODULE\r\n\r\n#define SSAO_KERNEL_SIZE 32\r\n#define SSAO_BIAS 0.\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций расчета затенения окружающего освещения\r\n// в экранном пространстве (Screen-Space Ambient Occlusion)\r\n// ----------------------------------------------------------------------------\r\n\r\nuniform mediump float uCameraViewAngle;\r\nuniform vec3 uSSAOSamples[SSAO_KERNEL_SIZE];\r\n\r\nin float vFocus;\r\n\r\n/**\r\n * Функция определения затенения окружающего освещения для случая перспективной проекции\r\n *   pos - положение фрагмента в видовых координатах (координаты xy 0,0 соответствуют центру экрана, z - напрвлена за экран )\r\n *   normal - нормаль фрагмента в глобальных координатах\r\n *   rand - случайный вектор в глобальных координатах\r\n */\r\nfloat calcSSAO(vec3 pos, vec3 normal, vec3 rand, sampler2D depthTexture, float radius) {\r\n\r\n  vec3 tangent = normalize(rand - normal * dot(rand, normal));\r\n  vec3 bitangent = cross(normal, tangent);\r\n  // матрица преобразования в видовую систему координат\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n\r\n  vec2 k = vec2(1, vAspectB);\r\n\r\n  // проверка на размер спроецированной полусферы выборки\r\n  // строго должен быть больше пикселя для включения алгоритма\r\n  // эксперименты показали, что алгоритм заметен при maxScreenRadius>10\r\n  float maxScreenRadius = vFocus/(vFocus+pos.z)*radius*uTextureBResolution.x;\r\n  if(maxScreenRadius <= 10.) return 1.;\r\n\r\n  float occlusion = 0.;\r\n  for(int i=0; i<SSAO_KERNEL_SIZE; i++) {\r\n    vec3 s = TBN * uSSAOSamples[i];\r\n    s = pos + radius * s;\r\n\r\n    vec2 t = vFocus/(vFocus+s.z)*k;\r\n    vec2 ts = t*s.xy;\r\n    vec2 offset = vec2(0.5)+0.5*ts;\r\n\r\n    float sampleDepth = s.z*texture(depthTexture, offset).w/length(s);\r\n    if(abs(ts.x)>1. || abs(ts.y)>1.) {\r\n      sampleDepth = MAX_TERRAIN_DISTANCE;\r\n    }\r\n    \r\n    float rangeCheck = smoothstep(0., 1., radius/abs(pos.z - sampleDepth));\r\n    occlusion += (sampleDepth >= (s.z + SSAO_BIAS) ? 0. : 1.) * rangeCheck;    \r\n  }\r\n\r\n  return 1. - occlusion/float(SSAO_KERNEL_SIZE);\r\n}\r\n\r\n\r\n/**\r\n * Функция определения затенения окружающего освещения для случая орто-проекции\r\n *   pos - положение фрагмента в видовых координатах (координаты xy 0,0 соответствуют центру экрана, z - напрвлена за экран )\r\n *   normal - нормаль фрагмента в глобальных координатах\r\n *   rand - случайный вектор в глобальных координатах\r\n */\r\nfloat calcSSAOOrtho(vec3 pos, vec3 normal, vec3 rand, sampler2D depthTexture, vec2 scale, float SSAO_RADIUS) {\r\n\r\n  vec3 tangent = normalize(rand - normal * dot(rand, normal));\r\n  vec3 bitangent = cross(normal, tangent);\r\n  // матрица преобразования в видовую систему координат\r\n  mat3 TBN = mat3(tangent, bitangent, normal);\r\n\r\n  float occlusion = 0.;\r\n  for(int i=0; i<SSAO_KERNEL_SIZE; i++) {\r\n    vec3 s = TBN * uSSAOSamples[i];\r\n    s = pos + SSAO_RADIUS * s;\r\n\r\n    vec2 ts = scale*s.xy;\r\n    vec2 offset = vec2(0.5)+0.5*ts;\r\n\r\n    float sampleDepth = texture(depthTexture, offset).w;\r\n    if(abs(ts.x)>1. || abs(ts.y)>1.) {\r\n      sampleDepth = MAX_TRN_ELEVATION;\r\n    }\r\n    \r\n    float rangeCheck = 1.;//smoothstep(0., 1., SSAO_RADIUS/abs(pos.z - sampleDepth));\r\n    occlusion += (sampleDepth >= (s.z + SSAO_BIAS) ? 0. : 1.) * rangeCheck;    \r\n  }\r\n\r\n  //return bitangent;\r\n  return 1. - occlusion/float(SSAO_KERNEL_SIZE);\r\n\r\n}\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций расчета атмосферного рассеивания\r\n// ----------------------------------------------------------------------------\r\n#ifndef ATM_MODULE\r\n\r\n#define ATM_MODULE\r\n// ----------------------------------------------------------------------------\r\n// Модуль расчета атмосферного рассеяния\r\n// ----------------------------------------------------------------------------\r\n\r\n// Коэффициенты рассеивания Релея для трех частот спектра (rgb) на уровне моря \r\nuniform vec3 uBetaRayleigh;\r\n// Коэффициенты рассеивания Ми для трех частот спектра (rgb) на уровне моря \r\nuniform vec3 uBetaMie;\r\n// Коэффициент фазового рассеивания Ми\r\nuniform float uGMie;\r\n// Масштабная высота (высота 50% плотности молекул воздуха)\r\n// x - для рассеивания Релея\r\n// y - для рассеивания Ми\r\nuniform vec2 uScaleHeight;\r\n// Радиус атмосферы\r\nuniform float uAtmRadius;\r\n// Радиус планеты\r\nuniform float uPlanetRadius;\r\n// Положение центра планеты\r\nuniform vec3 uPlanetCenter;\r\n\r\nconst int PRIMARY_STEPS = 32; // primary steps, affects quality the most\r\n\r\nconst float SQRTPILN2HALF = 1.04345246;\r\n// Приближение функции Чапмана, домноженная на exp(-x)\r\n// функция возвращает оптическую глубину (интеграл плотности вдоль луча от указанной высоты до бесконечности)\r\n// в двух каналах (x - Релея, y - Ми)\r\n// X - референсная нормализованная высота (R/H), R - радиус планеты, H - характеристическая высота плотности атмосферы (высота 50% массы)\r\n// x - нормализованная высота ((R+h)/H), h - высота над уровнем планеты\r\n// cosTheta - косинус угла наклона луча к зениту\r\nvec2 ChHold(vec2 X, vec2 x, float cosTheta) {\r\n  vec2 R = X + x;\r\n  vec2 c = SQRTPILN2HALF*sqrt(R);\r\n  // theta выше горизонта\r\n  if(cosTheta >= 0.) return c/(c*cosTheta + vec2(1.0)) * exp(-x);\r\n  // theta ниже горизонта\r\n  else {\r\n      vec2 x0 = sqrt(vec2(1.0) - cosTheta*cosTheta) * R;\r\n      vec2 c0 = SQRTPILN2HALF*sqrt(x0);\r\n      return 2.0*c0*exp(X-x0) - c/(vec2(1.0) - c*cosTheta) * exp(-x);\r\n  }\r\n}\r\n\r\nvec2 ChH(vec2 X, vec2 h, float cosTheta) {\r\n  vec2 x = X+h;\r\n  vec2 c = SQRTPILN2HALF * sqrt(x);\r\n  vec2 cexp = c*exp(-h);\r\n  // theta выше горизонта\r\n  if(cosTheta >= 0.) return cexp/((c-vec2(1.))*cosTheta + vec2(1.));\r\n  // theta ниже горизонта\r\n  else {\r\n    float sinTheta = sqrt(1.-cosTheta*cosTheta);\r\n    return cexp/((c-vec2(1.))*cosTheta - vec2(1.)) + 2.*c*exp(X - x*sinTheta)*sqrt(sinTheta);\r\n  }\r\n}\r\n\r\nconst float ONE_DIV4PI = 1./(4.*PI);\r\n\r\nstruct ResultScattering {\r\n  vec3 t; // Мультипликативная часть (transmittance), цвет поглощения\r\n  vec3 i; //Аддитивная часть (in-scatter), цвет подсвечивания за счет рассеивания атмосферы\r\n};\r\n\r\n/** \r\n * Функция вычисления атмосферного рассеивания\r\n *   ro - положение камеры\r\n *   rd - направление луча камеры\r\n *   ld - направление на источник света\r\n *   noise - случайное число в диапазоне 0...1 для смещения начальной точки чтобы избежать полос на сильных градиентах\r\n */\r\nResultScattering scattering(vec3 ro, vec3 rd, vec3 ld, float noise) {\r\n  // Положение относительно центра планеты\r\n  vec3 start = ro - uPlanetCenter;\r\n\r\n  float PLANET_RADIUS_SQR = uPlanetRadius*uPlanetRadius;\r\n  float ATM_RADIUS_SQR = uAtmRadius*uAtmRadius;\r\n  \r\n  float r2 = dot(start,start); // квадрат расстояния до центра планеты\r\n  float OT = -dot(start,rd); // расстояния вдоль луча до точки минимального расстояния до центра планеты\r\n  float CT2 = r2 - OT*OT; // квадрат минимального расстояния от луча до центра планеты\r\n  if(CT2 >= ATM_RADIUS_SQR) return ResultScattering(vec3(0), vec3(1)); // луч проходит выше атмосферы\r\n  float AT = sqrt(ATM_RADIUS_SQR - CT2); // расстояние на луче от точки на поверхности атмосферы до точки минимального расстояния до центра планеты\r\n  float rayLen = 2.*AT; // длина луча до выхода из атмосферы или до касания с планетой\r\n  if(r2 > ATM_RADIUS_SQR) {\r\n    // выше атмосферы\r\n    if(OT < 0.) return ResultScattering(vec3(0), vec3(1)); // направление от планеты\r\n    // камера выше атмосферы, поэтому переопределяем начальную точку как точку входа в атмосферу\r\n    start += rd*(OT - AT);\r\n    r2 = ATM_RADIUS_SQR;\r\n    OT = AT;\r\n  }\r\n  else rayLen = AT - dot(start, rd); // пересчитываем длину луча с учетом нахождения внутри сферы атмосферы\r\n\r\n  vec3 normal = normalize(start);\r\n  float NdotD = dot(normal, rd);\r\n  float isNotPlanetIntersect = 1.;\r\n  if(NdotD < 0.) {\r\n    // Поиск длины луча в случае попадания в поверхность планеты\r\n    if(CT2 < PLANET_RADIUS_SQR) {\r\n      rayLen = OT - sqrt(PLANET_RADIUS_SQR - CT2);\r\n      isNotPlanetIntersect = 0.;\r\n    }\r\n  }\r\n  \r\n  // Расчет фазовой функции\r\n  // Для рассеяния Релея постоянная g считается равной нулю, рассеяние симметрично относительно положительных и отрицательных углов\r\n  // Для рассеяния Ми g принимают 0,76 ... 0,999.\r\n  // Отрицательные значения g рассеивают больше в прямом направлении, а положительные - рассеивают свет назад к источнику света\r\n  float mu = dot(rd, ld);\r\n  float mu2 = mu * mu;\r\n  float g2 = uGMie * uGMie;\r\n  float phaseRayleigh = 0.75 * (1. + mu2) * ONE_DIV4PI;\r\n  float A = max(0., 1. + uGMie*(uGMie - 2.*mu));\r\n  float phaseMie = 1.5 * (1. + mu2)*(1. - g2) / ((2. + g2)*sqrt(A*A*A)) * ONE_DIV4PI;\r\n    \r\n  float stepSize = rayLen/float(PRIMARY_STEPS); // длина шага\r\n  vec3 step = rd*stepSize; // шаг вдоль луча\r\n  vec3 nextpos = start + step; // следующая точка\r\n  vec3 pos = start + noise*step; // смещение на случайную долю шага для избежания выраженных полос\r\n\r\n  // оптическая глубина x - Релея, y - Ми, z - озон\r\n  vec2 optDepth = vec2(0.);\r\n  vec3 totalRayleigh = vec3(0.);\r\n  vec3 totalMie = vec3(0.);\r\n\r\n  vec2 fDensity = stepSize*exp(-(length(start)-uPlanetRadius)/uScaleHeight);\r\n\r\n  for (int i=0; i<PRIMARY_STEPS; i++, nextpos += step, pos += step) {\r\n    // определение оптической глубины вдоль луча камеры (считаем как среднее по краям сегмента)\r\n    vec2 density = stepSize*exp(-(length(nextpos)-uPlanetRadius)/uScaleHeight);\r\n    optDepth += 0.5*(density + fDensity);\r\n    fDensity = density;\r\n   \r\n    // определение оптической глубины вдоль луча к солнцу (считаем из средней точки сегмента)\r\n    // определение виден ли источник света из данной точки\r\n    float OT = dot(pos, ld); // расстояния вдоль направления на свет до точки минимального расстояния до центра планеты\r\n    float CT2 = dot(pos, pos) - OT*OT; // квадрат минимального расстояния от луча до центра планеты\r\n    if(OT>0. || CT2 > PLANET_RADIUS_SQR)  {\r\n      vec3 normal = normalize(pos);\r\n      // источник света виден из данной точки\r\n      vec2 optDepth2 = uScaleHeight * ChH(uPlanetRadius/uScaleHeight, (length(pos)-uPlanetRadius)/uScaleHeight, dot(normal, ld));\r\n\r\n      // ослабление света за счет рассеивания\r\n      // T(CP) * T(PA) = T(CPA) = exp{ -β(λ) [D(CP) + D(PA)]}\r\n      vec3 attn = exp(-uBetaRayleigh*(optDepth.x+optDepth2.x) - uBetaMie*(optDepth.y+optDepth2.y));\r\n\r\n      // total += T(CP) * T(PA) * ρ(h) * ds\r\n      totalRayleigh += density.x * attn;\r\n      totalMie += density.y * attn;\r\n    }\r\n  }\r\n  vec3 inScatter = exp(-uBetaRayleigh*optDepth.x - isNotPlanetIntersect*uBetaMie*optDepth.y);\r\n\r\n  // I = I_S * β(λ) * γ(θ) * total\r\n  vec3 transmittance = phaseRayleigh*uBetaRayleigh*totalRayleigh + phaseMie*uBetaMie*totalMie;\r\n  return ResultScattering(transmittance, inScatter);\r\n}\r\n\r\n\r\nconst int PRIMARY_STEPS_INTERSECTION = 8;\r\n/** \r\n * Функция вычисления атмосферного рассеивания при известном пересечении с поверхностью\r\n *   ro - положение камеры\r\n *   rd - направление луча камеры\r\n *   ld - направление на источник света\r\n *   rayLen - дистанция до пересечения луча с поверхностью\r\n * В функции вырезано отраженное рассеивание Ми, т.к. невозможно учесть все пересечения лучей с ландшафтом \r\n */\r\nResultScattering scatteringWithIntersection(vec3 ro, vec3 rd, vec3 ld, float rayLen) {\r\n  \r\n  // Положение относительно центра планеты\r\n  vec3 start = ro - uPlanetCenter;\r\n\r\n  float PLANET_RADIUS_SQR = uPlanetRadius*uPlanetRadius;\r\n  float ATM_RADIUS_SQR = uAtmRadius*uAtmRadius;\r\n\r\n  // Расчет фазовой функции\r\n  // Для рассеяния Релея постоянная g считается равной нулю, рассеяние симметрично относительно положительных и отрицательных углов\r\n  // Для рассеяния Ми g принимают 0,76 ... 0,999.\r\n  // Отрицательные значения g рассеивают больше в прямом направлении, а положительные - рассеивают свет назад к источнику света\r\n  float mu = dot(rd, ld);\r\n  float phaseRayleigh = 0.75 * (1. + mu*mu) * ONE_DIV4PI;\r\n    \r\n  float stepSize = rayLen/float(PRIMARY_STEPS_INTERSECTION); // длина шага\r\n  vec3 step = rd*stepSize; // шаг вдоль луча\r\n  vec3 nextpos = start + step; // следующая точка\r\n  vec3 pos = start + 0.5*step; // смещение на половину шага для более точного интегрирования по серединам отрезков\r\n\r\n  // оптическая глубина x - Релея, y - Ми, z - озон\r\n  vec2 optDepth = vec2(0.);\r\n  vec3 totalRayleigh = vec3(0.);\r\n\r\n  vec2 fDensity = stepSize*exp(-(length(start)-uPlanetRadius)/uScaleHeight);\r\n\r\n  for (int i=0; i<PRIMARY_STEPS_INTERSECTION; i++, nextpos += step, pos += step) {\r\n    // определение оптической глубины вдоль луча камеры (считаем как среднее по краям сегмента)\r\n    vec2 density = stepSize*exp(-(length(nextpos)-uPlanetRadius)/uScaleHeight);\r\n    optDepth += 0.5*(density + fDensity);\r\n    fDensity = density;\r\n   \r\n    // определение оптической глубины вдоль луча к солнцу (считаем из средней точки сегмента)\r\n    // определение виден ли источник света из данной точки\r\n    float OT = dot(pos, ld); // расстояния вдоль направления на свет до точки минимального расстояния до центра планеты\r\n    float CT2 = dot(pos, pos) - OT*OT; // квадрат минимального расстояния от луча до центра планеты\r\n    if(OT>0. || CT2 > PLANET_RADIUS_SQR)  {\r\n      vec3 normal = normalize(pos);\r\n      // источник света виден из данной точки\r\n      vec2 optDepth2 = uScaleHeight * ChH(uPlanetRadius/uScaleHeight, (length(pos)-uPlanetRadius)/uScaleHeight, dot(normal, ld));\r\n\r\n      // ослабление света за счет рассеивания\r\n      // T(CP) * T(PA) = T(CPA) = exp{ -β(λ) [D(CP) + D(PA)]}\r\n      vec3 attn = exp(-uBetaRayleigh*(optDepth.x+optDepth2.x) - uBetaMie*(optDepth.y+optDepth2.y));\r\n\r\n      // total += T(CP) * T(PA) * ρ(h) * ds\r\n      totalRayleigh += density.x * attn;\r\n    }\r\n  }\r\n  vec3 inScatter = exp(-uBetaRayleigh*optDepth.x);\r\n\r\n  // I = I_S * β(λ) * γ(θ) * total\r\n  vec3 transmittance = phaseRayleigh*uBetaRayleigh*totalRayleigh;\r\n  return ResultScattering(transmittance, inScatter);\r\n}\r\n\r\n/** \r\n  * Функция определения пересечения луча с планетой\r\n  *   ro - положение камеры\r\n  *   rd - направление луча\r\n  * Возвращает 0. если луч пересекается с планетой\r\n  */\r\nfloat planetIntersection(vec3 ro, vec3 rd) {\r\n  vec3 pos = ro - uPlanetCenter;\r\n  //vec3 pos = vec3(0, ro.y+uPlanetRadius, 0);\r\n  \r\n  float OT = dot(pos, rd); // расстояния вдоль луча до точки минимального расстояния до центра планеты\r\n  if(OT > 0.) return 1.;\r\n  float CT2 = dot(pos, pos)-OT*OT; // минимальное расстоянии от луча до центра планеты\r\n  float R2 = uPlanetRadius*uPlanetRadius;\r\n  return step(R2,CT2);\r\n  //if(OT>0. || CT2>(uPlanetRadius*uPlanetRadius)) return 1.;\r\n  //return 0.;\r\n}\r\n\r\n/** \r\n  * Функция определения мягкой тени от сферической поверхности планеты\r\n  *   ro - положение точки, для которой производится рассчет\r\n  *   rd - направление луча на солнце\r\n  * Возвращает значения от 0. до 1.\r\n  *   0. - если солнце полностью скрыто планетой\r\n  *   1. - если солнце полностью видно\r\n  */\r\nfloat softPlanetShadow(vec3 ro, vec3 rd) {\r\n  vec3 pos = ro - uPlanetCenter;\r\n  //vec3 pos = vec3(0, ro.y+uPlanetRadius, 0);\r\n\r\n  float OT = dot(pos, rd); // расстояния вдоль луча до точки минимального расстояния до центра планеты\r\n  float CT = sqrt(dot(pos, pos) - OT*OT); // минимальное расстоянии от луча до центра планеты\r\n  if(OT>0.) return 1.;\r\n  float d = (uPlanetRadius-CT)/OT;\r\n  return smoothstep(-uSunDiscAngleSin, uSunDiscAngleSin, d);\r\n}\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функции отображения ночного неба\r\n// ----------------------------------------------------------------------------\r\n#ifndef SKY_MODULE\r\n#define SKY_MODULE\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функции отображения ночного неба\r\n// ----------------------------------------------------------------------------\r\n\r\nuniform sampler2D uTextureMilkyway;\r\nuniform sampler2D uTextureConstellation;\r\n\r\n// яркость разметки созвездий на небе\r\nuniform float uConstellationsColor;\r\n\r\nvec3 nightSky(vec3 rd) {\r\n  vec2 ts = vec2(0.5*atan(rd.x,rd.z), 0.5*PI+atan(rd.y,length(rd.xz)));\r\n  vec3 col = texture(uTextureMilkyway, ts/PI).rgb + uConstellationsColor*texture(uTextureConstellation, ts/PI).rgb;\r\n  col = pow(col, vec3(2.2));\r\n  return col;\r\n}\r\n\r\n#endif\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций постобработки\r\n// ----------------------------------------------------------------------------\r\n#ifndef POSTPROC_MODULE\r\n#define POSTPROC_MODULE\r\n\r\n// ----------------------------------------------------------------------------\r\n// Модуль определения функций постобработки\r\n// ----------------------------------------------------------------------------\r\n\r\n/**\r\n * Преобразование в линейное цветовое пространство из sRGB\r\n */\r\nvec3 eotf(vec3 arg) {\treturn pow(arg, vec3(2.2)); }\r\n\r\n/**\r\n * Преобразование в sRGB из линейного цветового пространства\r\n */\r\nvec3 oetf(vec3 arg) {\treturn pow(arg, vec3(1./2.2)); }\r\n\r\n// Матрица преобразования цветового пространства из базиса (615,535,445) в sRGB\r\nmat3 mat2sRGB = mat3(\r\n   1.6218, -0.4493,  0.0325,\r\n  -0.0374,  1.0598, -0.0742,\r\n  -0.0283, -0.1119,  1.0491\r\n);\r\n\r\n/**\r\n * Квантование цвета и дитеринг (добавление шума, чтобы не было резких переходов между квантами цвета)\r\n * quant = 1./255.\r\n */\r\nvec3 quantize_and_dither(vec3 col, float quant, vec2 fcoord) {\r\n\tvec3 noise = .5/65536. +\r\n    texelFetch( uTextureBlueNoise, ivec2( fcoord / 8. ) & ( 1024 - 1 ), 0 ).xyz * 255./65536. +\r\n    texelFetch( uTextureBlueNoise, ivec2( fcoord )\t\t & ( 1024 - 1 ), 0 ).xyz * 255./256.;\r\n\tvec3 c0 = floor( oetf( col ) / quant ) * quant;\r\n\tvec3 c1 = c0 + quant;\r\n\tvec3 discr = mix( eotf( c0 ), eotf( c1 ), noise );\r\n\treturn mix( c0, c1, lessThan( discr, col ) );\r\n}\r\n\r\n#endif\r\n\r\n/** \r\n * Функция неламбертового диффузного рассеивания.\r\n * Среднее законов Lambert и Lommel-Seeliger\r\n *   omega - альбедо\r\n *   omega_0 - альбедо одиночного рассеивания\r\n *   mu - косинус угла между нормалью и направлением на камеру\r\n *   mu0 - косинус угла между нормалью и направлением на источник света\r\n */\r\nvec3 lunar_lambert(vec3 omega, float mu, float mu_0) {\r\n\tvec3 omega_0 = 244. * omega/(184.*omega + 61.);\r\n\treturn omega_0 * ( 0.5*omega*(1.+sqrt(mu*mu_0)) + .25/max(0.4, mu+mu_0) );\r\n}\r\n\r\n\r\nvec3 render(vec3 ro, float t, vec3 rd, vec3 nor, vec3 albedo, float ssao, vec3 light1, vec3 light2) {\r\n  // косинус угла между лучем и солнцем \r\n  vec3 col = vec3(0);\r\n  vec3 pos = vec3(0);\r\n  int shadowIterations = 0;\r\n  float shadowDistance = 0.;\r\n  pos = ro + t*rd;\r\n  // цвет\r\n  vec3 kd = albedo;\r\n  // ambient\r\n  float amb = clamp(0.5+0.5*nor.y, 0., 1.);\r\n  vec3 light = light1;\r\n  vec3 lightcolor = uSunDiscColor;\r\n  if(light1.y < 0.) {\r\n    light = light2;\r\n    lightcolor = uMoonDiscColor;\r\n  }\r\n  //vec3 hal = normalize(light-rd);\r\n\r\n  float LdotN = dot(light, nor);\r\n  float RdotN = clamp(-dot(rd, nor), 0., 1.);\r\n\r\n  // 1-ая световая ракета\r\n  vec3 fd0 = uFlarePositions[0]-pos;\r\n  float fdist0sqr = dot(fd0,fd0);\r\n  fd0 /= sqrt(fdist0sqr);\r\n  float F0dotN = clamp(dot(fd0, nor), 0., 1.);\r\n  // 2-ая световая ракета\r\n  vec3 fd1 = uFlarePositions[1]-pos;\r\n  float fdist1sqr = dot(fd1,fd1);\r\n  fd1 /= sqrt(fdist1sqr);\r\n  float F1dotN = clamp(dot(fd1, nor), 0., 1.);\r\n\r\n  float xmin = 6.*uSunDiscAngleSin; // синус половины углового размера солнца (здесь увеличен в 6 раз для мягкости), задает границу плавного перехода\r\n  float shd = 0.;\r\n  if(LdotN>-xmin) {\r\n    shd = softPlanetShadow(pos, light);\r\n    if(shd>0.001) shd *= softShadow(pos, light, t, shadowIterations, shadowDistance);\r\n    if(shd>=1.) shadowDistance = 2.*MAX_TERRAIN_DISTANCE;\r\n  }\r\n  float dx = clamp(0.5*(xmin-LdotN)/xmin, 0., 1.);\r\n  LdotN = clamp(xmin*dx*dx + LdotN, 0., 1.);\r\n\r\n  vec3 lunar = uSkyColor*amb*ssao*lunar_lambert(kd, RdotN, amb)     // свет от неба\r\n    + lightcolor*LdotN*shd*lunar_lambert(kd, RdotN, LdotN)  // свет солнца или луны\r\n    + uHeadLight*RdotN*lunar_lambert(kd, RdotN, RdotN)/(t*t)   // свет фар\r\n    + uFlareLights[0]*F0dotN*lunar_lambert(kd, RdotN, F0dotN)/(fdist0sqr)  // свет 1-ой сигнальной ракеты\r\n    + uFlareLights[1]*F1dotN*lunar_lambert(kd, RdotN, F1dotN)/(fdist1sqr);  // свет 2-ой сигнальной ракеты\r\n  col = lunar;//mix(lomm, lunar, LvsR);\r\n  \r\n  //////////////////\r\n  // fog\r\n  //float fo = 1.0-exp(-pow(0.00009*t,1.5) );\r\n  //col = mix(col, FOG_COLOR, fo );\r\n\r\n  #ifdef SHADOWS_ITERATIONS_VIEW\r\n  col = vec3(shadowIterations)/100.;\r\n  #endif\r\n\r\n  #ifdef SHADOW_DISTANCE_VIEW\r\n  col = shadowDistance==0. ? vec3(1,0,0) : shadowDistance>MAX_TERRAIN_DISTANCE ? vec3(0,0,1) : vec3(shadowDistance)/3000.;\r\n  #endif\r\n\r\n  return col;\r\n}\r\n\r\nvoid main() {\r\n  vec2 k = vAspect > vAspectB\r\n    ? vec2(1, vAspectB/vAspect)\r\n    : vec2(vAspect/vAspectB, 1);\r\n  vec2 uv = vec2(0.5)+k*(gl_FragCoord.xy/uResolution-0.5);\r\n\r\n#ifdef DEPTH_ERROR_VIEW\r\n  uv = gl_FragCoord.xy/uResolution;\r\n  float depthA = texture(uTextureProgramA, uv).w;\r\n#endif\r\n\r\n  vec4 albedoB = texture(uAlbedoProgramB, uv);\r\n  vec4 normalDepthB = texture(uNormalDepthProgramB, uv);\r\n\r\n#ifdef DEPTH_ERROR_VIEW\r\n  float derr = normalDepthB.w-depthA;\r\n  vec3 col = derr<0. ? vec3(-derr,0,0) : vec3(derr/100.);\r\n  col = pow(col, vec3(1./2.2));\r\n\r\n#else\r\n  vec3 col = albedoB.rgb;\r\n  float t = normalDepthB.w;\r\n  vec3 rd = normalize(vRay);\r\n\r\n  float LvsR = step(0.5, gl_FragCoord.x/uResolution.x);\r\n\r\n\r\n#ifdef TEST_VIEW\r\n  col = render(uCameraPosition, t, rd, normalDepthB.xyz, col, 1., uSunDirection, uMoonDirection);\r\n#else\r\n \tfloat noise = texture(uTextureBlueNoise, gl_FragCoord.xy/1024.).x;\r\n  vec3 rand = vec3(1,0,0);//texture(uTextureSSAONoise, gl_FragCoord.xy/4.).xyz;\r\n\r\n  vec3 posScreen;\r\n  vec3 normal;\r\n  float ssao;\r\n  if(uScreenMode.x == MAP_VIEW) {\r\n    normal = normalDepthB.xzy*vec3(1, 1, -1);\r\n    vec2 uv1 = uMapScale*vec2(1, 1./vAspectB)*(gl_FragCoord.xy/uResolution-0.5);\r\n    posScreen = vec3(uv1.x, uv1.y, t);\r\n    ssao = calcSSAOOrtho(posScreen, normal, rand, uNormalDepthProgramB, 2.*vec2(1, vAspectB)*k/uMapScale, 300.);\r\n  }\r\n  else {\r\n    normal = vInverseTransformMat*normalDepthB.xyz;\r\n    normal.z = -normal.z;\r\n    posScreen = normalize(vRayScreen)*t;\r\n    posScreen.z = -posScreen.z;\r\n    ssao = calcSSAO(posScreen, normal, rand, uNormalDepthProgramB, 300.);\r\n  }\r\n  //col = (uSSAOSamples[int(mod(0.1*gl_FragCoord.x,64.))]);\r\n  //col = vec3(ssao*ssao);\r\n  //col = posScreen/1000.;\r\n  //col = vec3(1);\r\n  //col *= ssao;\r\n\r\n  if(uScreenMode.x == MAP_VIEW) {\r\n    col *= clamp(0.5+0.5*normalDepthB.y, 0., 1.);\r\n    col *= ssao*ssao;\r\n  }\r\n  else {\r\n    \r\n    //col *= clamp(0.5+0.5*normalDepthB.y, 0., 1.);\r\n    //col = vec3(ssao*ssao);\r\n\r\n    // косинус угла между лучем и солнцем \r\n    float sundot = clamp(dot(rd,uSunDirection),0.,1.);\r\n    float moondot = clamp(dot(rd,uMoonDirection),0.,1.);\r\n    if(t>MAX_TERRAIN_DISTANCE) {\r\n      // небо из текстуры\r\n      col = 0.5*nightSky(normalize(vRaySky));\r\n      // диск солнца\r\n      float sunsin = sqrt(1.-sundot*sundot);\r\n      col += sunsin < uSunDiscAngleSin ? vec3(1.,0.8,0.6) : vec3(0);\r\n      // диск луны\r\n      float moonsin = 1. - smoothstep(uSunDiscAngleSin-0.001,uSunDiscAngleSin+0.001,sqrt(1.-moondot*moondot));\r\n      col += moonsin;\r\n      // горизонт планеты\r\n      col *= planetIntersection(uCameraPosition, rd);\r\n      // атмосферное рассеивание\r\n      ResultScattering rs;\r\n      rs = scattering(uCameraPosition, rd, uSunDirection, mix(0.3,0.7,noise));\r\n      col = rs.t*LIGHT_INTENSITY + rs.i*col;\r\n    }\r\n    else {\r\n      col = render(uCameraPosition, t, rd, normalDepthB.xyz, col, ssao*ssao, uSunDirection, uMoonDirection);\r\n      ResultScattering rs = scatteringWithIntersection(uCameraPosition, rd, uSunDirection, t);\r\n      // считаем, что средняя длина дени равна max(MAX_TRN_ELEVATION*(tan(alpha)-tan(phi)),0.)\r\n      // alpha - угол направления на солнце к зениту\r\n      // phi - среднестатистический угол наклона склонов к зениту (принимаем 45 градусов, tan(phi)=1.)\r\n      float tanAlpha = sqrt(1. - uSunDirection.z*uSunDirection.z) / max(0.01, uSunDirection.z);\r\n      float shDist = max(MAX_TRN_ELEVATION*(tanAlpha-1.),0.);\r\n      shDist = clamp(shDist, MAX_TRN_ELEVATION, 5000.);\r\n      float scatDist = max(0., t-shDist); // примерная средняя дистанция на которой происходит рассеивание\r\n      //scatDist = mix(scatDist, t, uCameraInShadow*shd);\r\n\r\n      col = scatDist/t * rs.t*LIGHT_INTENSITY + rs.i*col; // добавлен коэффициент учитывающий луч в тени\r\n    }\r\n\r\n    // 1-ая световая ракета\r\n    vec3 fd = uFlarePositions[0] - uCameraPosition;\r\n    float fdist2 = dot(fd, fd);\r\n    float fdist = sqrt(fdist2);\r\n    fd /= fdist;\r\n    float f = dot(fd, rd);\r\n    if(f>=0.999999 && fdist<t) {\r\n      col = uFlareLights[0];\r\n      t = fdist;\r\n    }\r\n    // 2-ая световая ракета\r\n    fd = uFlarePositions[1] - uCameraPosition;\r\n    fdist2 = dot(fd, fd);\r\n    fdist = sqrt(fdist2);\r\n    fd /= fdist;\r\n    f = dot(fd, rd);\r\n    if(f>=0.999999 && fdist<t) {\r\n      col = uFlareLights[1];\r\n      t = fdist;\r\n    }\r\n\r\n    float exposure = 2.;\r\n    // тональная компрессия с экспозицией\r\n    col = vec3(1.) - exp(-col * exposure);\r\n    // засвечивание солнцем\r\n    col += 0.2*uCameraInShadow*normalize(uSunDiscColor)*pow(sundot, 8.0);\r\n  }\r\n#endif\r\n\r\n  //col = posScreen/1000.;\r\n  col = quantize_and_dither(col.rgb, 1./255., gl_FragCoord.xy);\r\n\r\n  //col = pow(col, vec3(1./2.2));\r\n  \r\n#endif\r\n\r\n  fragColor = vec4(col, 1.);\r\n}\r\n "},978:(t,r,e)=>{e.r(r),e.d(r,{default:()=>n});const n="#version 300 es\r\n\r\n// разрешение экрана\r\nuniform mediump vec2 uResolution;\r\nuniform mediump vec2 uTextureBResolution;\r\n\r\nuniform mat3 uTransformMat;\r\nuniform mat3 uSkyTransformMat;\r\nuniform mediump float uCameraViewAngle;\r\n\r\nin vec3 aVertexPosition;\r\n\r\nout vec3 vRay;    // Лучи в системе координат планеты\r\nout vec3 vRaySky; // Лучи в системе координат небесного свода\r\nout vec3 vRayScreen; // Лучи в экранной системе координат\r\nout mat3 vInverseTransformMat; // Инверсированная матрица преобразования (для работы SSAO)\r\nout float vAspect; // Соотношение сторон рендербуфера\r\nout float vAspectB; // Соотношение сторон буфера программы B\r\nout float vFocus; // Фокусное расстояние камеры\r\n\r\nvoid main() {\r\n  gl_Position = vec4(aVertexPosition, 1.0);\r\n  float t = tan(0.5*uCameraViewAngle);\r\n  vFocus = 1./t;\r\n  vAspect = uResolution.x/uResolution.y;\r\n  vAspectB = uTextureBResolution.x/uTextureBResolution.y;\r\n  vec2 k = vAspect > vAspectB \r\n    ? vec2(1, 1./vAspect)\r\n    : vec2(vAspect/vAspectB, 1./vAspectB);\r\n\r\n  //vRayScreen = vec3(aVertexPosition.xy*uResolution*t/uResolution.x, -1.);\r\n  //vRay = uTransformMat*vRayScreen;\r\n  vRayScreen = vec3(aVertexPosition.xy*k*t, -1.);\r\n  vRay = uTransformMat * vRayScreen;\r\n  vRaySky = vRay*uSkyTransformMat;\r\n  vInverseTransformMat = transpose(uTransformMat);\r\n}\r\n"}},e={};function n(t){var i=e[t];if(void 0!==i)return i.exports;var s=e[t]={exports:{}};return r[t].call(s.exports,s,s.exports,n),s.exports}n.n=t=>{var r=t&&t.__esModule?()=>t.default:()=>t;return n.d(r,{a:r}),r},n.d=(t,r)=>{for(var e in r)n.o(r,e)&&!n.o(t,e)&&Object.defineProperty(t,e,{enumerable:!0,get:r[e]})},n.o=(t,r)=>Object.prototype.hasOwnProperty.call(t,r),n.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},t=n(752),n.n(t)()()})();